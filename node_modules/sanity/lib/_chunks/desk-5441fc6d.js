var _templateObject, _templateObject2, _templateObject3, _templateObject4, _templateObject5, _templateObject6, _templateObject7, _templateObject8, _templateObject9, _templateObject10, _templateObject11, _templateObject12, _templateObject13, _templateObject14, _templateObject15, _templateObject16, _templateObject17, _templateObject18, _templateObject19, _templateObject20, _templateObject21, _templateObject22, _templateObject23, _templateObject24, _templateObject25, _templateObject26, _templateObject27, _templateObject28, _templateObject29, _templateObject30, _templateObject31, _templateObject32, _templateObject33, _templateObject34, _templateObject35;
function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }
import { PublishIcon, EditIcon, InfoOutlineIcon, UnknownIcon, WarningOutlineIcon, DocumentsIcon, ChevronDownIcon, ClipboardIcon, CheckmarkIcon, EllipsisVerticalIcon, ComposeIcon, TrashIcon, ResetIcon, CopyIcon, RestoreIcon, UnpublishIcon, CloseIcon, ErrorOutlineIcon, CheckmarkCircleIcon, AddCircleIcon, SelectIcon, MasterDetailIcon, BinaryDocumentIcon, EarthAmericasIcon, SortIcon, StackCompactIcon, StackIcon } from '@sanity/icons';
import React, { useState, useEffect, useMemo, isValidElement, createContext, forwardRef, useContext, useCallback, useId, memo, useRef, createElement, Fragment as Fragment$1, lazy } from 'react';
import { jsx, Fragment, jsxs } from 'react/jsx-runtime';
import { useSchema, unstable_useValuePreview, useTimeAgo, createHookFromObservableFactory, getDraftId, getPublishedId, useClient, DEFAULT_STUDIO_CLIENT_OPTIONS, useDocumentStore, TextWithTone, isRecord, getPreviewStateObservable, SanityDefaultPreview, getPreviewValueWithFallback, DocumentPreviewPresence, useUnique, useDocumentPresence, useDocumentPreviewStore, PreviewCard, TooltipOfDisabled, StatusButton, LegacyLayerProvider, useCurrentUser, InsufficientPermissionsMessage, useTemplates, useTemplatePermissions, EMPTY_ARRAY as EMPTY_ARRAY$1, EMPTY_OBJECT, useDocumentOperation, useDocumentPairPermissions, useValidationStatus, useSyncState, useEditState, isArray, pathToString, isValidationError, isValidationWarning, UserAvatar, CommandList, useTimelineSelector, visitDiff, ScrollContainer, ChangeFieldWrapper, DiffTooltip, NoChanges, DocumentChangeContext, ChangeList, definePlugin, useSource, usePresenceStore, useInitialValue, useConnectionState, useTimelineStore, toMutationPatches, setAtPath, useDocumentValuePermissions, useFormState, getExpandOperations, FieldActionsResolver, FieldActionsProvider, getConfigContextFromSource, useConfigContextFromSource } from 'sanity';
import { Tooltip, Box, Text, Inline, rem, Flex, Card, Container, useToast, Stack, Label, Button, Dialog, Grid, Spinner, ErrorBoundary, MenuDivider, MenuGroup, MenuItem, MenuButton, Menu, Layer, useForwardedRef, BoundaryElementProvider, TextSkeleton, rgba, useElementRect, LayerProvider, AvatarStack, Popover, useClickOutside, useGlobalKeyDown } from '@sanity/ui';
import styled, { css } from 'styled-components';
import { fromEvent, timer, EMPTY, of, from } from 'rxjs';
import { switchMap, startWith, map, distinctUntilChanged, shareReplay, catchError, debounceTime } from 'rxjs/operators';
import CopyToClipboard from 'react-copy-to-clipboard';
import isNumber from 'lodash/isNumber.js';
import isString from 'lodash/isString.js';
import { useMemoObservable, useAsObservable } from 'react-rx';
import { StateLink, useIntentLink, IntentLink, useRouter, route } from 'sanity/router';
import omit from 'lodash/omit.js';
import { toString, fromString, resolveKeyedPath } from '@sanity/util/paths';
import uniqBy from 'lodash/uniqBy.js';
import negate from 'lodash/negate.js';
import { isValidationErrorMarker } from '@sanity/types';
import { uuid } from '@sanity/uuid';
import { format } from 'date-fns';
import upperFirst from 'lodash/upperFirst.js';
import isHotkey from 'is-hotkey';
import { isActionEnabled } from '@sanity/schema/_internal';
import camelCase from 'lodash/camelCase.js';
import speakingurl from 'speakingurl';
import uniq from 'lodash/uniq.js';
import kebabCase from 'lodash/kebabCase.js';
import pickBy from 'lodash/pickBy.js';
import find from 'lodash/find.js';
import uniqueId from 'lodash/uniqueId.js';
import { isValidElementType } from 'react-is';
import startCase from 'lodash/startCase.js';
function Delay(_ref) {
  let {
    children,
    ms = 0
  } = _ref;
  const [ready, setReady] = useState(ms <= 0);
  useEffect(() => {
    if (ms <= 0) {
      return void 0;
    }
    const timeoutId = setTimeout(() => setReady(true), ms);
    return () => {
      clearTimeout(timeoutId);
    };
  }, [ms]);
  if (!ready || !children) {
    return /* @__PURE__ */jsx(Fragment, {});
  }
  return typeof children === "function" ? children() : children;
}
function DocTitle(props) {
  const {
    document: documentValue
  } = props;
  const schema = useSchema();
  const schemaType = schema.get(documentValue._type);
  const {
    error,
    value
  } = unstable_useValuePreview({
    schemaType,
    value: documentValue
  });
  if (!schemaType) {
    return /* @__PURE__ */jsxs("code", {
      children: ["Unknown schema type: ", documentValue._type]
    });
  }
  if (error) {
    return /* @__PURE__ */jsxs(Fragment, {
      children: ["Error: ", error.message]
    });
  }
  return /* @__PURE__ */jsx(Fragment, {
    children: (value == null ? void 0 : value.title) || /* @__PURE__ */jsx("span", {
      style: {
        color: "var(--card-muted-fg-color)"
      },
      children: "Untitled"
    })
  });
}
function TimeAgo(_ref2) {
  let {
    time
  } = _ref2;
  const timeAgo = useTimeAgo(time);
  return /* @__PURE__ */jsxs("span", {
    title: timeAgo,
    children: [timeAgo, " ago"]
  });
}
function isClientError(e) {
  if (typeof e !== "object") return false;
  if (!e) return false;
  return "statusCode" in e && "response" in e;
}
const POLL_INTERVAL = 5e3;
let visiblePoll$;
const getVisiblePoll$ = () => {
  if (!visiblePoll$) {
    visiblePoll$ = fromEvent(document, "visibilitychange").pipe(
    // add empty emission to have this fire on creation
    startWith(null), map(() => document.visibilityState === "visible"), distinctUntilChanged(), switchMap(visible => visible ?
    // using timer instead of interval since timer will emit on creation
    timer(0, POLL_INTERVAL) : EMPTY), shareReplay({
      refCount: true,
      bufferSize: 1
    }));
  }
  return visiblePoll$;
};
function getDocumentExistence(documentId, _ref3) {
  let {
    versionedClient
  } = _ref3;
  const draftId = getDraftId(documentId);
  const publishedId = getPublishedId(documentId);
  const requestOptions = {
    uri: versionedClient.getDataUrl("doc", "".concat(draftId, ",").concat(publishedId)),
    json: true,
    query: {
      excludeContent: "true"
    },
    tag: "use-referring-documents.document-existence"
  };
  return versionedClient.observable.request(requestOptions).pipe(map(_ref4 => {
    let {
      omitted
    } = _ref4;
    const nonExistant = omitted.filter(doc => doc.reason === "existence");
    if (nonExistant.length === 2) {
      return void 0;
    }
    if (nonExistant.length === 0) {
      return publishedId;
    }
    return nonExistant.some(doc => doc.id === draftId) ? publishedId : draftId;
  }));
}
function fetchCrossDatasetReferences(documentId, context) {
  const {
    versionedClient
  } = context;
  return getVisiblePoll$().pipe(switchMap(() => getDocumentExistence(documentId, context)), switchMap(checkDocumentId => {
    if (!checkDocumentId) {
      return of({
        totalCount: 0,
        references: []
      });
    }
    const currentDataset = versionedClient.config().dataset;
    return versionedClient.observable.request({
      url: "/data/references/".concat(currentDataset, "/documents/").concat(checkDocumentId, "/to?excludeInternalReferences=true&excludePaths=true"),
      tag: "use-referring-documents.external"
    }).pipe(catchError(e => {
      if (isClientError(e) && e.statusCode === 404) {
        return of({
          totalCount: 0,
          references: []
        });
      }
      throw e;
    }));
  }));
}
const useInternalReferences = createHookFromObservableFactory(_ref5 => {
  let [documentId, documentStore] = _ref5;
  const referencesClause = "*[references($documentId)][0...100]{_id,_type}";
  const totalClause = "count(*[references($documentId)])";
  const fetchQuery = "{\"references\":".concat(referencesClause, ",\"totalCount\":").concat(totalClause, "}");
  const listenQuery = "*[references($documentId)]";
  return documentStore.listenQuery({
    fetch: fetchQuery,
    listen: listenQuery
  }, {
    documentId
  }, {
    tag: "use-referring-documents",
    transitions: ["appear", "disappear"],
    throttleTime: 5e3
  });
});
const useCrossDatasetReferences = createHookFromObservableFactory(_ref6 => {
  let [documentId, versionedClient] = _ref6;
  return getVisiblePoll$().pipe(switchMap(() => fetchCrossDatasetReferences(documentId, {
    versionedClient
  })));
});
function useReferringDocuments(documentId) {
  const versionedClient = useClient(DEFAULT_STUDIO_CLIENT_OPTIONS);
  const documentStore = useDocumentStore();
  const publishedId = getPublishedId(documentId);
  const [internalReferences, isInternalReferencesLoading] = useInternalReferences(useMemo(() => [publishedId, documentStore], [documentStore, publishedId]));
  const [crossDatasetReferences, isCrossDatasetReferencesLoading] = useCrossDatasetReferences(useMemo(() => [publishedId, versionedClient], [publishedId, versionedClient]));
  const projectIds = useMemo(() => {
    return Array.from(new Set(crossDatasetReferences == null ? void 0 : crossDatasetReferences.references.map(crossDatasetReference => crossDatasetReference.projectId).filter(Boolean))).sort();
  }, [crossDatasetReferences == null ? void 0 : crossDatasetReferences.references]);
  const datasetNames = useMemo(() => {
    return Array.from(new Set(crossDatasetReferences == null ? void 0 : crossDatasetReferences.references.map(crossDatasetReference => (crossDatasetReference == null ? void 0 : crossDatasetReference.datasetName) || "").filter(datasetName => Boolean(datasetName) && datasetName !== ""))).sort();
  }, [crossDatasetReferences == null ? void 0 : crossDatasetReferences.references]);
  const hasUnknownDatasetNames = useMemo(() => {
    return Boolean(crossDatasetReferences == null ? void 0 : crossDatasetReferences.references.some(crossDatasetReference => typeof crossDatasetReference.datasetName !== "string"));
  }, [crossDatasetReferences == null ? void 0 : crossDatasetReferences.references]);
  return {
    totalCount: ((internalReferences == null ? void 0 : internalReferences.totalCount) || 0) + ((crossDatasetReferences == null ? void 0 : crossDatasetReferences.totalCount) || 0),
    projectIds,
    datasetNames,
    hasUnknownDatasetNames,
    internalReferences,
    crossDatasetReferences,
    isLoading: isInternalReferencesLoading || isCrossDatasetReferencesLoading
  };
}
function PublishedStatus(props) {
  const {
    document
  } = props;
  const updatedAt = document && "_updatedAt" in document && document._updatedAt;
  return /* @__PURE__ */jsx(Tooltip, {
    portal: true,
    content: /* @__PURE__ */jsx(Box, {
      padding: 2,
      children: /* @__PURE__ */jsx(Text, {
        size: 1,
        children: document ? /* @__PURE__ */jsxs(Fragment, {
          children: ["Published ", updatedAt && /* @__PURE__ */jsx(TimeAgo, {
            time: updatedAt
          })]
        }) : /* @__PURE__ */jsx(Fragment, {
          children: "Not published"
        })
      })
    }),
    children: /* @__PURE__ */jsx(TextWithTone, {
      tone: "positive",
      dimmed: !document,
      muted: !document,
      size: 1,
      children: /* @__PURE__ */jsx(PublishIcon, {})
    })
  });
}
function DraftStatus(props) {
  const {
    document
  } = props;
  const updatedAt = document && "_updatedAt" in document && document._updatedAt;
  return /* @__PURE__ */jsx(Tooltip, {
    portal: true,
    content: /* @__PURE__ */jsx(Box, {
      padding: 2,
      children: /* @__PURE__ */jsx(Text, {
        size: 1,
        children: document ? /* @__PURE__ */jsxs(Fragment, {
          children: ["Edited ", updatedAt && /* @__PURE__ */jsx(TimeAgo, {
            time: updatedAt
          })]
        }) : /* @__PURE__ */jsx(Fragment, {
          children: "No unpublished edits"
        })
      })
    }),
    children: /* @__PURE__ */jsx(TextWithTone, {
      tone: "caution",
      dimmed: !document,
      muted: !document,
      size: 1,
      children: /* @__PURE__ */jsx(EditIcon, {})
    })
  });
}
function PaneItemPreview(props) {
  const {
    icon,
    layout,
    presence,
    schemaType,
    value
  } = props;
  const title = isRecord(value.title) && isValidElement(value.title) || isString(value.title) || isNumber(value.title) ? value.title : null;
  const {
    draft,
    published,
    isLoading
  } = useMemoObservable(() => getPreviewStateObservable(props.documentPreviewStore, schemaType, value._id, title), [props.documentPreviewStore, schemaType, value._id, title]);
  const status = isLoading ? null : /* @__PURE__ */jsxs(Inline, {
    space: 4,
    children: [presence && presence.length > 0 && /* @__PURE__ */jsx(DocumentPreviewPresence, {
      presence
    }), /* @__PURE__ */jsx(PublishedStatus, {
      document: published
    }), /* @__PURE__ */jsx(DraftStatus, {
      document: draft
    })]
  });
  return /* @__PURE__ */jsx(SanityDefaultPreview, {
    ...getPreviewValueWithFallback({
      value,
      draft,
      published
    }),
    isPlaceholder: isLoading,
    icon,
    layout,
    status
  });
}
function missingContext() {
  throw new Error("Pane is missing router context");
}
const PaneRouterContext = createContext({
  index: 0,
  groupIndex: 0,
  siblingIndex: 0,
  payload: void 0,
  params: {},
  hasGroupSiblings: false,
  groupLength: 0,
  routerPanesState: [],
  BackLink: () => missingContext(),
  ChildLink: () => missingContext(),
  ReferenceChildLink: () => missingContext(),
  handleEditReference: () => missingContext(),
  ParameterizedLink: () => missingContext(),
  replaceCurrent: () => missingContext(),
  closeCurrent: () => missingContext(),
  duplicateCurrent: () => missingContext(),
  setView: () => missingContext(),
  setParams: () => missingContext(),
  setPayload: () => missingContext(),
  navigateIntent: () => missingContext()
});
const BackLink = forwardRef(function BackLink2(props, ref) {
  const {
    routerPanesState,
    groupIndex
  } = useContext(PaneRouterContext);
  const panes = useMemo(() => routerPanesState.slice(0, groupIndex), [groupIndex, routerPanesState]);
  const state = useMemo(() => ({
    panes
  }), [panes]);
  return /* @__PURE__ */jsx(StateLink, {
    ...props,
    ref,
    state
  });
});
const ChildLink = forwardRef(function ChildLink2(props, ref) {
  const {
    childId,
    childPayload,
    childParameters,
    ...rest
  } = props;
  const {
    routerPanesState,
    groupIndex
  } = useContext(PaneRouterContext);
  return /* @__PURE__ */jsx(StateLink, {
    ...rest,
    ref,
    state: {
      panes: [...routerPanesState.slice(0, groupIndex + 1), [{
        id: childId,
        params: childParameters,
        payload: childPayload
      }]]
    }
  });
});
const ReferenceChildLink = forwardRef(function ReferenceChildLink2(_ref7, ref) {
  let {
    documentId,
    documentType,
    parentRefPath,
    children,
    template,
    ...rest
  } = _ref7;
  return /* @__PURE__ */jsx(ChildLink, {
    ...rest,
    ref,
    childId: documentId,
    childPayload: template == null ? void 0 : template.params,
    childParameters: {
      type: documentType,
      parentRefPath: toString(parentRefPath),
      ...(template && {
        template: template == null ? void 0 : template.id
      })
    },
    children
  });
});
const ParameterizedLink = forwardRef(function ParameterizedLink2(props, ref) {
  const {
    routerPanesState: currentPanes,
    groupIndex,
    siblingIndex
  } = useContext(PaneRouterContext);
  const {
    params,
    payload,
    ...rest
  } = props;
  const nextParams = useUnique(params);
  const nextPayload = useUnique(payload);
  const nextState = useMemo(() => {
    const currentGroup = currentPanes[groupIndex];
    const currentSibling = currentGroup[siblingIndex];
    const nextSibling = {
      ...currentSibling,
      params: nextParams != null ? nextParams : currentSibling.params,
      payload: nextPayload != null ? nextPayload : currentSibling.payload
    };
    const nextGroup = [...currentGroup.slice(0, siblingIndex), nextSibling, ...currentGroup.slice(siblingIndex + 1)];
    const nextPanes = [...currentPanes.slice(0, groupIndex), nextGroup, ...currentPanes.slice(groupIndex + 1)];
    return {
      panes: nextPanes
    };
  }, [currentPanes, groupIndex, nextParams, nextPayload, siblingIndex]);
  return /* @__PURE__ */jsx(StateLink, {
    ref,
    ...rest,
    state: nextState
  });
});
function usePaneRouter() {
  return useContext(PaneRouterContext);
}
const EMPTY_ARRAY = [];
function ReferencePreviewLink(props) {
  const {
    onClick,
    type,
    value
  } = props;
  const publishedId = getPublishedId(value == null ? void 0 : value._id);
  const documentPresence = useDocumentPresence(publishedId);
  const documentPreviewStore = useDocumentPreviewStore();
  const {
    ReferenceChildLink
  } = usePaneRouter();
  const Link = useCallback(function LinkComponent(linkProps) {
    return /* @__PURE__ */jsx(ReferenceChildLink, {
      documentId: value == null ? void 0 : value._id,
      documentType: type == null ? void 0 : type.name,
      parentRefPath: EMPTY_ARRAY,
      ...linkProps
    });
  }, [ReferenceChildLink, type == null ? void 0 : type.name, value == null ? void 0 : value._id]);
  return /* @__PURE__ */jsx(PreviewCard, {
    __unstable_focusRing: true,
    as: Link,
    "data-as": "a",
    onClick,
    padding: 2,
    radius: 2,
    children: /* @__PURE__ */jsx(PaneItemPreview, {
      documentPreviewStore,
      icon: type == null ? void 0 : type.icon,
      layout: "default",
      presence: (documentPresence == null ? void 0 : documentPresence.length) > 0 ? documentPresence : EMPTY_ARRAY,
      schemaType: type,
      value
    })
  });
}
const ChevronWrapper = styled(Box)(_templateObject || (_templateObject = _taggedTemplateLiteral(["\n  margin-left: auto;\n"])));
const CrossDatasetReferencesDetails = styled.details(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral(["\n  flex: none;\n\n  &[open] ", " {\n    transform: rotate(180deg);\n  }\n"])), ChevronWrapper);
const CrossDatasetReferencesSummary = styled.summary(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral(["\n  list-style: none;\n\n  &::-webkit-details-marker {\n    display: none;\n  }\n"])));
const TableContainer = styled(Box).attrs({
  paddingX: 2,
  paddingBottom: 2
})(_templateObject4 || (_templateObject4 = _taggedTemplateLiteral(["\n  overflow: auto;\n  max-height: 150px;\n"])));
const Table = styled.table(_templateObject5 || (_templateObject5 = _taggedTemplateLiteral(["\n  width: 100%;\n  text-align: left;\n  padding: 0 ", ";\n  border-collapse: collapse;\n\n  th {\n    padding: ", ";\n  }\n\n  thead > tr {\n    position: sticky;\n    top: 0;\n    background: var(--card-bg-color);\n    z-index: 1;\n  }\n\n  td {\n    padding: 0 ", ";\n  }\n\n  tr > *:last-child {\n    text-align: right;\n  }\n"])), _ref8 => {
  let {
    theme
  } = _ref8;
  return rem(theme.sanity.space[2]);
}, _ref9 => {
  let {
    theme
  } = _ref9;
  return rem(theme.sanity.space[1]);
}, _ref10 => {
  let {
    theme
  } = _ref10;
  return rem(theme.sanity.space[1]);
});
const DocumentIdFlex = styled(Flex)(_templateObject6 || (_templateObject6 = _taggedTemplateLiteral(["\n  min-height: 35px;\n"])));
const ReferencesCard = styled(Card).attrs({
  radius: 2,
  shadow: 1,
  marginBottom: 4,
  flex: "auto"
})(_templateObject7 || (_templateObject7 = _taggedTemplateLiteral(["\n  overflow: hidden;\n  overflow: clip;\n  min-height: 150px;\n"])));
const OtherReferenceCount = props => {
  const difference = props.totalCount - props.references.length;
  if (!difference) return null;
  return /* @__PURE__ */jsxs(Inline, {
    space: 2,
    children: [/* @__PURE__ */jsxs(Text, {
      size: 1,
      muted: true,
      children: [difference, " other reference", difference === 1 ? "" : "s", " not shown", " "]
    }), /* @__PURE__ */jsx(Tooltip, {
      portal: true,
      placement: "top",
      content: /* @__PURE__ */jsx(Container, {
        width: 0,
        children: /* @__PURE__ */jsx(Box, {
          padding: 2,
          children: /* @__PURE__ */jsx(Text, {
            size: 1,
            children: "We can't show metadata about these references because no token with access to the datasets they are in was found."
          })
        })
      }),
      children: /* @__PURE__ */jsx(Text, {
        size: 1,
        muted: true,
        children: /* @__PURE__ */jsx(InfoOutlineIcon, {})
      })
    })]
  });
};
function ConfirmDeleteDialogBody(_ref11) {
  let {
    crossDatasetReferences,
    internalReferences,
    documentTitle,
    totalCount,
    action,
    datasetNames,
    hasUnknownDatasetNames,
    onReferenceLinkClick
  } = _ref11;
  const schema = useSchema();
  const toast = useToast();
  const renderPreviewItem = useCallback(item => {
    const type = schema.get(item._type);
    if (type) {
      return /* @__PURE__ */jsx(ReferencePreviewLink, {
        type,
        value: item,
        onClick: onReferenceLinkClick
      });
    }
    return (
      // Padding added to match the ReferencePreviewLink styling
      /* @__PURE__ */
      jsx(Box, {
        padding: 2,
        children: /* @__PURE__ */jsx(SanityDefaultPreview, {
          icon: UnknownIcon,
          title: "Preview Unavailable",
          subtitle: "ID: ".concat(item._id),
          layout: "default"
        })
      })
    );
  }, [schema, onReferenceLinkClick]);
  if ((internalReferences == null ? void 0 : internalReferences.totalCount) === 0 && (crossDatasetReferences == null ? void 0 : crossDatasetReferences.totalCount) === 0) {
    return /* @__PURE__ */jsxs(Text, {
      as: "p",
      children: ["Are you sure you want to ", action, " ", /* @__PURE__ */jsxs("strong", {
        children: ["\u201C", documentTitle, "\u201D"]
      }), "?"]
    });
  }
  const documentCount = crossDatasetReferences.totalCount === 1 ? "1 document" : "".concat(crossDatasetReferences.totalCount.toLocaleString(), " documents");
  const normalizedDatasetNames = [...datasetNames, ...(hasUnknownDatasetNames ? ["unavailable"] : [])];
  const datasetsCount = normalizedDatasetNames.length === 1 ? "another dataset" : "".concat(normalizedDatasetNames.length, " datasets");
  let datasetNameList = "Dataset".concat(normalizedDatasetNames.length === 1 ? "" : "s", ": ").concat(normalizedDatasetNames.join(", "));
  if (hasUnknownDatasetNames && normalizedDatasetNames.length === 1) {
    datasetNameList = "Unavailable dataset";
  }
  return /* @__PURE__ */jsxs(Fragment, {
    children: [/* @__PURE__ */jsx(Card, {
      padding: 3,
      radius: 2,
      tone: "caution",
      marginBottom: 4,
      flex: "none",
      children: /* @__PURE__ */jsxs(Flex, {
        children: [/* @__PURE__ */jsx(Text, {
          "aria-hidden": "true",
          size: 1,
          children: /* @__PURE__ */jsx(WarningOutlineIcon, {})
        }), /* @__PURE__ */jsx(Box, {
          flex: 1,
          marginLeft: 3,
          children: /* @__PURE__ */jsx(Text, {
            size: 1,
            children: totalCount === 1 ? /* @__PURE__ */jsxs(Fragment, {
              children: ["1 document refers to \u201C", documentTitle, "\u201D"]
            }) : /* @__PURE__ */jsxs(Fragment, {
              children: [totalCount.toLocaleString(), " documents refer to \u201C", documentTitle, "\u201D"]
            })
          })
        })]
      })
    }), /* @__PURE__ */jsx(Box, {
      flex: "none",
      marginBottom: 4,
      children: /* @__PURE__ */jsxs(Text, {
        children: ["You may not be able to ", action, " \u201C", documentTitle, "\u201D because the following documents refer to it:"]
      })
    }), /* @__PURE__ */jsx(ReferencesCard, {
      children: /* @__PURE__ */jsxs(Flex, {
        direction: "column",
        height: "fill",
        children: [internalReferences.totalCount > 0 && /* @__PURE__ */jsxs(Stack, {
          as: "ul",
          padding: 3,
          space: 3,
          overflow: "auto",
          "data-testid": "internal-references",
          children: [internalReferences == null ? void 0 : internalReferences.references.map(item => /* @__PURE__ */jsx(Box, {
            as: "li",
            children: renderPreviewItem(item)
          }, item._id)), internalReferences.totalCount > internalReferences.references.length && /* @__PURE__ */jsx(Box, {
            as: "li",
            padding: 3,
            children: /* @__PURE__ */jsx(OtherReferenceCount, {
              ...internalReferences
            })
          })]
        }), crossDatasetReferences.totalCount > 0 && /* @__PURE__ */jsxs(CrossDatasetReferencesDetails, {
          "data-testid": "cross-dataset-references",
          style: {
            // only add the border if needed
            borderTop: internalReferences.totalCount > 0 ? "1px solid var(--card-shadow-outline-color)" : void 0
          },
          children: [/* @__PURE__ */jsx(CrossDatasetReferencesSummary, {
            children: /* @__PURE__ */jsxs(Flex, {
              padding: 4,
              align: "center",
              children: [/* @__PURE__ */jsx(Box, {
                marginRight: 4,
                children: /* @__PURE__ */jsx(Text, {
                  size: 3,
                  children: /* @__PURE__ */jsx(DocumentsIcon, {})
                })
              }), /* @__PURE__ */jsxs(Flex, {
                marginRight: 4,
                direction: "column",
                children: [/* @__PURE__ */jsx(Box, {
                  marginBottom: 2,
                  children: /* @__PURE__ */jsxs(Text, {
                    children: [documentCount, " in ", datasetsCount]
                  })
                }), /* @__PURE__ */jsx(Box, {
                  children: /* @__PURE__ */jsx(Text, {
                    title: datasetNameList,
                    textOverflow: "ellipsis",
                    size: 1,
                    muted: true,
                    children: datasetNameList
                  })
                })]
              }), /* @__PURE__ */jsx(ChevronWrapper, {
                children: /* @__PURE__ */jsx(Text, {
                  muted: true,
                  children: /* @__PURE__ */jsx(ChevronDownIcon, {})
                })
              })]
            })
          }), /* @__PURE__ */jsxs(TableContainer, {
            children: [/* @__PURE__ */jsxs(Table, {
              children: [/* @__PURE__ */jsx("thead", {
                children: /* @__PURE__ */jsxs("tr", {
                  children: [/* @__PURE__ */jsx("th", {
                    children: /* @__PURE__ */jsx(Label, {
                      muted: true,
                      size: 0,
                      children: "Project ID"
                    })
                  }), /* @__PURE__ */jsx("th", {
                    children: /* @__PURE__ */jsx(Label, {
                      muted: true,
                      size: 0,
                      children: "Dataset"
                    })
                  }), /* @__PURE__ */jsx("th", {
                    children: /* @__PURE__ */jsx(Label, {
                      muted: true,
                      size: 0,
                      children: "Document ID"
                    })
                  })]
                })
              }), /* @__PURE__ */jsx("tbody", {
                children: crossDatasetReferences.references.filter(reference => {
                  return "projectId" in reference;
                }).map((_ref12, index) => {
                  let {
                    projectId,
                    datasetName,
                    documentId
                  } = _ref12;
                  return (
                    // eslint-disable-next-line react/no-array-index-key
                    /* @__PURE__ */
                    jsxs("tr", {
                      children: [/* @__PURE__ */jsx("td", {
                        children: /* @__PURE__ */jsx(Text, {
                          size: 1,
                          children: projectId
                        })
                      }), /* @__PURE__ */jsx("td", {
                        children: /* @__PURE__ */jsx(Text, {
                          size: 1,
                          children: datasetName || "unavailable"
                        })
                      }), /* @__PURE__ */jsx("td", {
                        children: /* @__PURE__ */jsxs(DocumentIdFlex, {
                          align: "center",
                          gap: 2,
                          justify: "flex-end",
                          children: [/* @__PURE__ */jsx(Text, {
                            textOverflow: "ellipsis",
                            size: 1,
                            children: documentId || "unavailable"
                          }), documentId && /* @__PURE__ */jsx(CopyToClipboard, {
                            text: documentId,
                            onCopy: () => {
                              toast.push({
                                title: "Copied document ID to clipboard!",
                                status: "success"
                              });
                            },
                            children: /* @__PURE__ */jsx(Button, {
                              title: "Copy ID to clipboard",
                              mode: "bleed",
                              icon: ClipboardIcon,
                              fontSize: 0
                            })
                          })]
                        })
                      })]
                    }, "".concat(documentId, "-").concat(index))
                  );
                })
              })]
            }), /* @__PURE__ */jsx(Box, {
              padding: 2,
              children: /* @__PURE__ */jsx(OtherReferenceCount, {
                ...crossDatasetReferences
              })
            })]
          })]
        })]
      })
    }), /* @__PURE__ */jsx(Box, {
      flex: "none",
      children: /* @__PURE__ */jsxs(Text, {
        children: ["If you ", action, " this document, documents that refer to it will no longer be able to access it."]
      })
    })]
  });
}
const DialogBody = styled(Flex).attrs({
  padding: 4,
  direction: "column",
  height: "fill"
})(_templateObject8 || (_templateObject8 = _taggedTemplateLiteral(["\n  box-sizing: border-box;\n"])));
const LoadingContainer = styled(Flex).attrs({
  align: "center",
  direction: "column",
  justify: "center"
})(_templateObject9 || (_templateObject9 = _taggedTemplateLiteral(["\n  height: 300px;\n"])));
function ConfirmDeleteDialog(_ref13) {
  let {
    id,
    type,
    action = "delete",
    onCancel,
    onConfirm
  } = _ref13;
  const dialogId = "deletion-confirmation-".concat(useId());
  const {
    internalReferences,
    crossDatasetReferences,
    isLoading,
    totalCount,
    projectIds,
    datasetNames,
    hasUnknownDatasetNames
  } = useReferringDocuments(id);
  const capitalizedAction = "".concat(action.substring(0, 1).toUpperCase()).concat(action.substring(1));
  const documentTitle = /* @__PURE__ */jsx(DocTitle, {
    document: useMemo(() => ({
      _id: id,
      _type: type
    }), [id, type])
  });
  const showConfirmButton = !isLoading;
  return /* @__PURE__ */jsx(Dialog, {
    width: 1,
    id: dialogId,
    header: "".concat(capitalizedAction, " document?"),
    footer: /* @__PURE__ */jsxs(Grid, {
      columns: showConfirmButton ? 2 : 1,
      gap: 2,
      paddingX: 4,
      paddingY: 3,
      children: [/* @__PURE__ */jsx(Button, {
        mode: "ghost",
        onClick: onCancel,
        text: "Cancel"
      }), showConfirmButton && /* @__PURE__ */jsx(Button, {
        "data-testid": "confirm-delete-button",
        text: totalCount > 0 ? "".concat(capitalizedAction, " anyway") : "".concat(capitalizedAction, " now"),
        tone: "critical",
        onClick: onConfirm
      })]
    }),
    onClose: onCancel,
    onClickOutside: onCancel,
    children: /* @__PURE__ */jsx(DialogBody, {
      children: crossDatasetReferences && internalReferences && !isLoading ? /* @__PURE__ */jsx(ConfirmDeleteDialogBody, {
        crossDatasetReferences,
        internalReferences,
        documentTitle,
        isLoading,
        totalCount,
        action,
        projectIds,
        datasetNames,
        hasUnknownDatasetNames,
        onReferenceLinkClick: onCancel
      }) : /* @__PURE__ */jsxs(LoadingContainer, {
        "data-testid": "loading-container",
        children: [/* @__PURE__ */jsx(Spinner, {
          muted: true
        }), /* @__PURE__ */jsx(Box, {
          marginTop: 3,
          children: /* @__PURE__ */jsx(Text, {
            align: "center",
            muted: true,
            size: 1,
            children: "Looking for referring documents\u2026"
          })
        })]
      })
    })
  });
}
function ConfirmDeleteDialogContainer(props) {
  const id = useId();
  const [error, setError] = useState(null);
  const handleRetry = useCallback(() => setError(null), []);
  return error ? /* @__PURE__ */jsx(Dialog, {
    id: "dialog-error-".concat(id),
    "data-testid": "confirm-delete-error-dialog",
    header: "Error",
    footer: /* @__PURE__ */jsx(Flex, {
      paddingX: 4,
      paddingY: 3,
      direction: "column",
      children: /* @__PURE__ */jsx(Button, {
        mode: "ghost",
        text: "Retry",
        onClick: handleRetry
      })
    }),
    onClose: props.onCancel,
    children: /* @__PURE__ */jsx(Box, {
      padding: 4,
      children: /* @__PURE__ */jsx(Text, {
        children: "An error occurred while loading referencing documents."
      })
    })
  }) : /* @__PURE__ */jsx(ErrorBoundary, {
    onCatch: setError,
    children: /* @__PURE__ */jsx(ConfirmDeleteDialog, {
      ...props
    })
  });
}
const MENU_GROUP_POPOVER_PROPS = {
  constrainSize: true,
  placement: "left-start",
  portal: true
};
function PaneMenuButtonItem(props) {
  const {
    disabled,
    isAfterGroup,
    node
  } = props;
  if (node.type === "divider") {
    return /* @__PURE__ */jsx(MenuDivider, {});
  }
  if (node.type === "group") {
    if (node.children.length === 0) {
      return null;
    }
    if (node.expanded) {
      return /* @__PURE__ */jsxs(Fragment, {
        children: [isAfterGroup && /* @__PURE__ */jsx(MenuDivider, {}), node.title && /* @__PURE__ */jsx(Box, {
          padding: 2,
          paddingBottom: 1,
          children: /* @__PURE__ */jsx(Label, {
            muted: true,
            size: 0,
            children: node.title
          })
        }), node.children.map((child, childIndex) => {
          var _a;
          return /* @__PURE__ */jsx(PaneMenuButtonItem, {
            disabled: disabled || Boolean(node.disabled),
            isAfterGroup: ((_a = node.children[childIndex - 1]) == null ? void 0 : _a.type) === "group",
            node: child
          }, child.key);
        })]
      });
    }
    return /* @__PURE__ */jsxs(Fragment, {
      children: [isAfterGroup && /* @__PURE__ */jsx(MenuDivider, {}), /* @__PURE__ */jsx(MenuGroup, {
        disabled,
        icon: node.icon,
        popover: MENU_GROUP_POPOVER_PROPS,
        text: node.title,
        children: node.children.map((child, childIndex) => {
          var _a;
          return /* @__PURE__ */jsx(PaneMenuButtonItem, {
            disabled: disabled || Boolean(node.disabled),
            isAfterGroup: ((_a = node.children[childIndex - 1]) == null ? void 0 : _a.type) === "group",
            node: child
          }, child.key);
        })
      })]
    });
  }
  return /* @__PURE__ */jsxs(Fragment, {
    children: [isAfterGroup && /* @__PURE__ */jsx(MenuDivider, {}), /* @__PURE__ */jsx(PaneContextMenuItemResolver, {
      disabled,
      node
    })]
  });
}
function PaneContextMenuItemResolver(props) {
  const {
    node
  } = props;
  if (node.intent) {
    return /* @__PURE__ */jsx(PaneContextIntentMenuItem, {
      ...props,
      intent: node.intent
    });
  }
  return /* @__PURE__ */jsx(PaneContextMenuItem, {
    ...props
  });
}
function PaneContextMenuItem(props) {
  var _a;
  const {
    disabled,
    node
  } = props;
  const tooltipContent = typeof node.disabled === "object" && /* @__PURE__ */jsx(Text, {
    size: 1,
    children: node.disabled.reason
  });
  return /* @__PURE__ */jsx(TooltipOfDisabled, {
    content: tooltipContent,
    placement: "left",
    children: /* @__PURE__ */jsx(MenuItem, {
      disabled: disabled || Boolean(node.disabled),
      hotkeys: (_a = node.hotkey) == null ? void 0 : _a.split("+"),
      icon: node.icon,
      iconRight: node.iconRight || node.selected && CheckmarkIcon,
      onClick: node.onAction,
      pressed: node.selected,
      text: node.title,
      tone: node.tone
    })
  });
}
function PaneContextIntentMenuItem(props) {
  var _a;
  const {
    disabled,
    intent,
    node
  } = props;
  const tooltipContent = typeof node.disabled === "object" && /* @__PURE__ */jsx(Text, {
    size: 1,
    children: node.disabled.reason
  });
  const intentLink = useIntentLink({
    intent: intent.type,
    params: intent.params
  });
  const handleClick = useCallback(event => {
    intentLink.onClick(event);
    node.onAction();
  }, [intentLink, node]);
  return /* @__PURE__ */jsx(TooltipOfDisabled, {
    content: tooltipContent,
    placement: "left",
    children: /* @__PURE__ */jsx(MenuItem, {
      as: "a",
      disabled: disabled || Boolean(node.disabled),
      hotkeys: (_a = node.hotkey) == null ? void 0 : _a.split("+"),
      href: intentLink.href,
      icon: node.icon,
      iconRight: node.selected ? CheckmarkIcon : void 0,
      onClick: handleClick,
      pressed: node.selected,
      text: node.title,
      tone: node.tone
    })
  });
}
const CONTEXT_MENU_POPOVER_PROPS = {
  constrainSize: true,
  placement: "bottom",
  portal: true
};
function nodesHasTone(nodes, tone) {
  return nodes.some(node => {
    return node.type === "item" && node.tone === tone || node.type === "group" && nodesHasTone(node.children, tone);
  });
}
function PaneContextMenuButton(props) {
  const {
    nodes
  } = props;
  const id = useId();
  const hasCritical = nodesHasTone(nodes, "critical");
  const hasCaution = nodesHasTone(nodes, "caution");
  return /* @__PURE__ */jsx(MenuButton, {
    button: /* @__PURE__ */jsx(StatusButton, {
      icon: EllipsisVerticalIcon,
      mode: "bleed",
      title: "Show menu",
      tone: hasCritical ? "critical" : hasCaution ? "caution" : void 0
    }),
    id,
    menu: /* @__PURE__ */jsx(Menu, {
      children: nodes.map((node, nodeIndex) => {
        var _a;
        const isAfterGroup = ((_a = nodes[nodeIndex - 1]) == null ? void 0 : _a.type) === "group";
        return /* @__PURE__ */jsx(PaneMenuButtonItem, {
          isAfterGroup,
          node
        }, node.key);
      })
    }),
    popover: CONTEXT_MENU_POPOVER_PROPS
  });
}
const PANE_DEBUG = false;
const PANE_COLLAPSED_WIDTH = 51;
const PANE_DEFAULT_MIN_WIDTH = PANE_COLLAPSED_WIDTH * 4;
const PaneContext = createContext(null);
const PaneLayoutContext = createContext(null);
function usePaneLayout() {
  const pane = useContext(PaneLayoutContext);
  if (!pane) {
    throw new Error("PaneLayout: missing context value");
  }
  return pane;
}
const Root$b = styled(Layer)(_templateObject10 || (_templateObject10 = _taggedTemplateLiteral(["\n  position: relative;\n  width: 1px;\n  min-width: 1px;\n\n  &:before {\n    content: '';\n    display: block;\n    position: absolute;\n    top: 0;\n    left: 0;\n    bottom: 0;\n    width: 1px;\n    background-color: var(--card-border-color);\n  }\n\n  &:not([data-disabled]) {\n    cursor: ew-resize;\n    width: 9px;\n    min-width: 9px;\n    margin: 0 -4px;\n\n    &:before {\n      left: 4px;\n    }\n\n    &:after {\n      content: '';\n      display: block;\n      position: absolute;\n      top: 0;\n      left: 0;\n      width: 9px;\n      bottom: 0;\n      background-color: var(--card-border-color);\n      opacity: 0;\n      transition: opacity 150ms;\n    }\n\n    &[data-dragging]:after,\n    &:hover:after {\n      opacity: 0.2;\n    }\n  }\n"])));
function PaneDivider(_ref14) {
  let {
    disabled,
    element
  } = _ref14;
  const {
    resize
  } = usePaneLayout();
  const [dragging, setDragging] = useState(false);
  const handleMouseDown = useCallback(event => {
    if (!element) return;
    setDragging(true);
    event.preventDefault();
    const startX = event.pageX;
    resize("start", element, 0);
    const handleMouseMove = e => {
      e.preventDefault();
      const deltaX = e.pageX - startX;
      resize("move", element, deltaX);
    };
    const handleMouseUp = e => {
      e.preventDefault();
      setDragging(false);
      window.removeEventListener("mousemove", handleMouseMove);
      window.removeEventListener("mouseup", handleMouseUp);
      resize("end", element, 0);
    };
    window.addEventListener("mousemove", handleMouseMove);
    window.addEventListener("mouseup", handleMouseUp);
  }, [element, resize]);
  return /* @__PURE__ */jsx(Root$b, {
    "data-disabled": disabled ? "" : void 0,
    "data-dragging": dragging ? "" : void 0,
    onMouseDown: handleMouseDown
  });
}
const Root$a = styled(Card)(_templateObject11 || (_templateObject11 = _taggedTemplateLiteral(["\n  outline: none;\n\n  // NOTE: This will render a border to the right side of each pane\n  // without taking up physical space.\n  box-shadow: 1px 0 0 var(--card-border-color);\n"])));
const Pane = forwardRef(function Pane2(props, ref) {
  var _a, _b, _c;
  const {
    children,
    currentMinWidth: currentMinWidthProp,
    currentMaxWidth: currentMaxWidthProp,
    flex: flexProp = 1,
    id,
    minWidth: minWidthProp,
    maxWidth: maxWidthProp,
    selected = false,
    ...restProps
  } = props;
  const [rootElement, setRootElement] = useState(null);
  const {
    collapse,
    collapsed: layoutCollapsed,
    expand,
    expandedElement,
    mount,
    panes
  } = usePaneLayout();
  const pane = panes.find(p => p.element === rootElement);
  const paneIndex = pane && panes.indexOf(pane);
  const nextPane = typeof paneIndex === "number" ? panes[paneIndex + 1] : void 0;
  const isLast = paneIndex === panes.length - 1;
  const collapsed = layoutCollapsed ? false : (pane == null ? void 0 : pane.collapsed) || false;
  const nextCollapsed = (nextPane == null ? void 0 : nextPane.collapsed) || false;
  const forwardedRef = useForwardedRef(ref);
  const flex = (_a = pane == null ? void 0 : pane.flex) != null ? _a : flexProp;
  const currentMinWidth = (_b = pane == null ? void 0 : pane.currentMinWidth) != null ? _b : currentMinWidthProp;
  const currentMaxWidth = (_c = pane == null ? void 0 : pane.currentMaxWidth) != null ? _c : currentMaxWidthProp;
  const setRef = useCallback(refValue => {
    setRootElement(refValue);
    forwardedRef.current = refValue;
  }, [forwardedRef]);
  useEffect(() => {
    if (!rootElement) return void 0;
    return mount(rootElement, {
      currentMinWidth: currentMinWidthProp,
      currentMaxWidth: currentMaxWidthProp,
      flex: flexProp,
      id,
      minWidth: minWidthProp,
      maxWidth: maxWidthProp
    });
  }, [currentMinWidthProp, currentMaxWidthProp, flexProp, id, minWidthProp, maxWidthProp, mount, rootElement]);
  const handleCollapse = useCallback(() => {
    if (!rootElement) return;
    collapse(rootElement);
  }, [collapse, rootElement]);
  const handleExpand = useCallback(() => {
    if (!rootElement) return;
    expand(rootElement);
  }, [expand, rootElement]);
  const contextValue = useMemo(() => ({
    collapse: handleCollapse,
    collapsed: layoutCollapsed ? false : collapsed,
    expand: handleExpand,
    index: paneIndex,
    isLast,
    rootElement
  }), [collapsed, handleCollapse, handleExpand, isLast, layoutCollapsed, paneIndex, rootElement]);
  const minWidth = useMemo(() => {
    if (layoutCollapsed) {
      return void 0;
    }
    if (collapsed) return PANE_COLLAPSED_WIDTH;
    if (currentMinWidth === 0) {
      return minWidthProp || PANE_DEFAULT_MIN_WIDTH;
    }
    if (isLast) {
      return minWidthProp || PANE_DEFAULT_MIN_WIDTH;
    }
    return currentMinWidth || minWidthProp || PANE_DEFAULT_MIN_WIDTH;
  }, [collapsed, currentMinWidth, isLast, layoutCollapsed, minWidthProp]);
  const maxWidth = useMemo(() => {
    if (collapsed) return PANE_COLLAPSED_WIDTH;
    if (layoutCollapsed && isLast) {
      return void 0;
    }
    if (isLast) {
      if (maxWidthProp) {
        return currentMaxWidth != null ? currentMaxWidth : maxWidthProp;
      }
      return void 0;
    }
    return currentMaxWidth != null ? currentMaxWidth : maxWidthProp;
  }, [collapsed, currentMaxWidth, isLast, layoutCollapsed, maxWidthProp]);
  const hidden = layoutCollapsed && !isLast;
  const divider = useMemo(() => !isLast && !layoutCollapsed && /* @__PURE__ */jsx(LegacyLayerProvider, {
    zOffset: "paneResizer",
    children: /* @__PURE__ */jsx(PaneDivider, {
      disabled: collapsed || nextCollapsed,
      element: rootElement
    })
  }), [collapsed, isLast, layoutCollapsed, nextCollapsed, rootElement]);
  const style = useMemo(() => ({
    flex,
    minWidth,
    maxWidth: maxWidth === Infinity ? void 0 : maxWidth
  }), [flex, minWidth, maxWidth]);
  return /* @__PURE__ */jsxs(Fragment, {
    children: [/* @__PURE__ */jsx(LegacyLayerProvider, {
      zOffset: "pane",
      children: /* @__PURE__ */jsx(PaneContext.Provider, {
        value: contextValue,
        children: /* @__PURE__ */jsxs(Root$a, {
          "data-testid": "pane",
          "data-ui": "Pane",
          tone: "inherit",
          hidden,
          id,
          overflow: layoutCollapsed ? void 0 : "hidden",
          ...restProps,
          "data-pane-collapsed": collapsed ? "" : void 0,
          "data-pane-index": paneIndex,
          "data-pane-selected": selected ? "" : void 0,
          ref: setRef,
          style,
          children: [PANE_DEBUG, /* @__PURE__ */jsx(BoundaryElementProvider, {
            element: rootElement,
            children: !hidden && /* @__PURE__ */jsx(Flex, {
              direction: "column",
              height: "fill",
              children
            })
          })]
        })
      })
    }), divider]
  });
});
function usePane() {
  const pane = useContext(PaneContext);
  if (!pane) {
    throw new Error("Pane: missing context value");
  }
  return pane;
}
const Root$9 = styled(Card)(_templateObject12 || (_templateObject12 = _taggedTemplateLiteral(["\n  position: relative;\n  outline: none;\n"])));
Root$9.displayName = "PaneContent__root";
const PaneContent = forwardRef(function PaneContent2(props, ref) {
  const {
    as,
    children,
    overflow,
    padding,
    ...restProps
  } = props;
  const {
    collapsed
  } = usePane();
  const {
    collapsed: layoutCollapsed
  } = usePaneLayout();
  return /* @__PURE__ */jsx(Root$9, {
    "data-testid": "pane-content",
    forwardedAs: as,
    ...restProps,
    flex: 1,
    hidden: collapsed,
    overflow: layoutCollapsed ? void 0 : overflow,
    padding,
    ref,
    tone: "inherit",
    children
  });
});
const Root$8 = styled(Layer)(_templateObject13 || (_templateObject13 = _taggedTemplateLiteral(["\n  position: sticky;\n  bottom: 0;\n\n  &:before {\n    content: '';\n    display: block;\n    position: absolute;\n    left: 0;\n    right: 0;\n    top: -1px;\n    border-bottom: 1px solid var(--card-shadow-outline-color);\n  }\n"])));
const RootCard = styled(Card)(_templateObject14 || (_templateObject14 = _taggedTemplateLiteral(["\n  padding-bottom: env(safe-area-inset-bottom);\n"])));
const PaneFooter = forwardRef(function PaneFooter2(props, ref) {
  const {
    children,
    padding
  } = props;
  const {
    collapsed
  } = usePane();
  return /* @__PURE__ */jsx(LegacyLayerProvider, {
    zOffset: "paneFooter",
    children: /* @__PURE__ */jsx(Root$8, {
      "data-testid": "pane-footer",
      hidden: collapsed,
      ref,
      children: /* @__PURE__ */jsx(RootCard, {
        tone: "inherit",
        children: /* @__PURE__ */jsx(Box, {
          padding,
          children
        })
      })
    })
  });
});
const Root$7 = styled(Layer)(_templateObject15 || (_templateObject15 = _taggedTemplateLiteral(["\n  line-height: 0;\n  position: sticky;\n  top: 0;\n\n  &:not([data-collapsed]):after {\n    content: '';\n    display: block;\n    position: absolute;\n    left: 0;\n    right: 0;\n    bottom: -1px;\n    border-bottom: 1px solid var(--card-shadow-outline-color);\n  }\n"])));
const Layout = styled(Flex)(_templateObject16 || (_templateObject16 = _taggedTemplateLiteral(["\n  transform-origin: calc(51px / 2);\n\n  [data-collapsed] > div > & {\n    transform: rotate(90deg);\n  }\n"])));
const TitleCard = styled(Card)(_ref15 => {
  let {
    theme
  } = _ref15;
  const {
    fg,
    bg
  } = theme.sanity.color.card.enabled;
  return css(_templateObject17 || (_templateObject17 = _taggedTemplateLiteral(["\n    background-color: ", ";\n\n    [data-ui='Text'] {\n      color: ", ";\n    }\n  "])), bg, fg);
});
const TitleTextSkeleton = styled(TextSkeleton)(_templateObject18 || (_templateObject18 = _taggedTemplateLiteral(["\n  width: 66%;\n  max-width: 175px;\n"])));
const TitleText = styled(Text)(_templateObject19 || (_templateObject19 = _taggedTemplateLiteral(["\n  cursor: default;\n  outline: none;\n"])));
const TabsBox = styled(Box)(_ref16 => {
  let {
    theme
  } = _ref16;
  const {
    color,
    space
  } = theme.sanity;
  return css(_templateObject20 || (_templateObject20 = _taggedTemplateLiteral(["\n    overflow: hidden;\n    overflow: clip;\n    position: relative;\n\n    & > div {\n      white-space: nowrap;\n      overflow: auto;\n      /* Hide scrollbars */\n      scrollbar-width: none;\n      &::-webkit-scrollbar {\n        width: 0;\n        height: 0;\n      }\n    }\n\n    /* right padding */\n    & > div:after {\n      content: '';\n      display: inline-block;\n      top: 0;\n      right: 0;\n      bottom: 0;\n      width: ", "px;\n      height: 1px;\n    }\n\n    /* Gradient that makes it look like tabs disappear into nothing (looks nicer) */\n    &:after {\n      content: '';\n      display: block;\n      position: absolute;\n      top: 0;\n      right: 0;\n      bottom: 0;\n      background: linear-gradient(to right, ", ", var(--card-bg-color));\n      width: ", "px;\n      pointer-events: none;\n    }\n  "])), space[3], rgba(color.base.bg, 0), space[3]);
});
const PaneHeader = forwardRef(function PaneHeader2(props, ref) {
  const {
    actions,
    backButton,
    contentAfter,
    loading,
    subActions,
    tabs,
    tabIndex,
    title
  } = props;
  const {
    collapse,
    collapsed,
    expand,
    rootElement: paneElement
  } = usePane();
  const paneRect = useElementRect(paneElement || null);
  const layoutStyle = useMemo(() => ({
    width: collapsed ? (paneRect == null ? void 0 : paneRect.height) || window.innerHeight : void 0
  }), [collapsed, paneRect]);
  const handleTitleClick = useCallback(() => {
    if (collapsed) return;
    collapse();
  }, [collapse, collapsed]);
  const handleLayoutClick = useCallback(() => {
    if (!collapsed) return;
    expand();
  }, [collapsed, expand]);
  const showTabsOrSubActions = Boolean(!collapsed && (tabs || subActions));
  return /* @__PURE__ */jsx(LayerProvider, {
    zOffset: 100,
    children: /* @__PURE__ */jsx(Root$7, {
      "data-collapsed": collapsed ? "" : void 0,
      "data-testid": "pane-header",
      ref,
      children: /* @__PURE__ */jsx(LegacyLayerProvider, {
        zOffset: "paneHeader",
        children: /* @__PURE__ */jsxs(Card, {
          "data-collapsed": collapsed ? "" : void 0,
          tone: "inherit",
          children: [/* @__PURE__ */jsxs(Layout, {
            onClick: handleLayoutClick,
            padding: 2,
            sizing: "border",
            style: layoutStyle,
            children: [backButton && /* @__PURE__ */jsx(Box, {
              flex: "none",
              padding: 1,
              children: backButton
            }), /* @__PURE__ */jsxs(TitleCard, {
              __unstable_focusRing: true,
              flex: 1,
              forwardedAs: "button",
              marginRight: actions ? 1 : 0,
              onClick: handleTitleClick,
              paddingLeft: backButton ? 1 : 3,
              paddingY: 3,
              tabIndex,
              children: [loading && /* @__PURE__ */jsx(TitleTextSkeleton, {
                animated: true,
                radius: 1
              }), !loading && /* @__PURE__ */jsx(TitleText, {
                textOverflow: "ellipsis",
                weight: "semibold",
                children: title
              })]
            }), actions && /* @__PURE__ */jsx(Box, {
              flex: "none",
              hidden: collapsed,
              children: /* @__PURE__ */jsx(LegacyLayerProvider, {
                zOffset: "paneHeader",
                children: actions
              })
            })]
          }), showTabsOrSubActions && /* @__PURE__ */jsxs(Flex, {
            align: "center",
            hidden: collapsed,
            overflow: "auto",
            paddingBottom: 3,
            paddingX: 3,
            paddingTop: 1,
            children: [/* @__PURE__ */jsx(TabsBox, {
              flex: 1,
              marginRight: subActions ? 3 : 0,
              children: tabs
            }), subActions && subActions]
          }), !collapsed && contentAfter && contentAfter]
        })
      })
    })
  });
});
function PaneHeaderActionButton(props) {
  const {
    node,
    padding
  } = props;
  if (node.type === "item") {
    return /* @__PURE__ */jsx(PaneHeaderMenuItemActionButton, {
      node,
      padding
    });
  }
  if (node.type === "group") {
    return /* @__PURE__ */jsx(PaneHeaderMenuGroupActionButton, {
      node,
      padding
    });
  }
  console.warn('unknown menu node (expected `type: "item" | "group"`):', node);
  return null;
}
function PaneHeaderMenuItemActionButton(props) {
  var _a;
  const {
    node,
    padding
  } = props;
  if (node.intent) {
    return /* @__PURE__ */jsx(PaneHeaderActionIntentButton, {
      ...props,
      intent: node.intent
    });
  }
  const disabledTooltipContent = typeof node.disabled === "object" && /* @__PURE__ */jsx(Text, {
    size: 1,
    children: node.disabled.reason
  });
  return /* @__PURE__ */jsx(TooltipOfDisabled, {
    content: disabledTooltipContent,
    placement: "bottom",
    children: /* @__PURE__ */jsx(StatusButton, {
      disabled: Boolean(node.disabled),
      hotkey: (_a = node.hotkey) == null ? void 0 : _a.split("+"),
      icon: node.icon,
      label: disabledTooltipContent ? void 0 : node.title,
      onClick: node.onAction,
      padding,
      selected: node.selected,
      tone: node.tone
    })
  });
}
function PaneHeaderActionIntentButton(props) {
  var _a;
  const {
    intent,
    node,
    padding
  } = props;
  const disabledTooltipContent = typeof node.disabled === "object" && /* @__PURE__ */jsx(Text, {
    size: 1,
    children: node.disabled.reason
  });
  const intentLink = useIntentLink({
    intent: intent.type,
    params: intent.params
  });
  const handleClick = useCallback(event => {
    intentLink.onClick(event);
    node.onAction();
  }, [intentLink, node]);
  return /* @__PURE__ */jsx(TooltipOfDisabled, {
    content: disabledTooltipContent,
    placement: "bottom",
    children: /* @__PURE__ */jsx(StatusButton, {
      as: "a",
      disabled: Boolean(node.disabled),
      hotkey: (_a = node.hotkey) == null ? void 0 : _a.split("+"),
      href: intentLink.href,
      icon: node.icon,
      label: disabledTooltipContent ? void 0 : node.title,
      onClick: handleClick,
      padding,
      selected: node.selected,
      tone: node.tone
    })
  });
}
function PaneHeaderMenuGroupActionButton(props) {
  var _a;
  const {
    node,
    padding
  } = props;
  return /* @__PURE__ */jsx(MenuButton, {
    button: /* @__PURE__ */jsx(StatusButton, {
      disabled: node.disabled,
      icon: (_a = node.icon) != null ? _a : UnknownIcon,
      label: node.title,
      padding
    }),
    id: useId(),
    menu: /* @__PURE__ */jsx(Menu, {
      children: node.children.map((child, idx) => {
        var _a2;
        return /* @__PURE__ */jsx(PaneMenuButtonItem, {
          disabled: Boolean(node.disabled),
          isAfterGroup: ((_a2 = node.children[idx - 1]) == null ? void 0 : _a2.type) === "group",
          node: child
        }, child.key);
      })
    })
  });
}
const Root$6 = styled(Card)(_templateObject21 || (_templateObject21 = _taggedTemplateLiteral(["\n  transition: opacity 200ms;\n  position: relative;\n  z-index: 1;\n  padding-left: env(safe-area-inset-left);\n  padding-right: env(safe-area-inset-right);\n  opacity: 0;\n\n  &:not([hidden]) {\n    display: flex;\n  }\n\n  &:not([data-collapsed]) {\n    overflow: auto;\n  }\n\n  &[data-mounted] {\n    opacity: 1;\n  }\n\n  &[data-resizing] {\n    pointer-events: none;\n  }\n"])));
function isMenuNodeButton(node) {
  return (node.type === "item" || node.type === "group") && node.renderAsButton;
}
const isNotMenuNodeButton = negate(isMenuNodeButton);
function resolveMenuNodes(params) {
  var _a, _b;
  const {
    fieldActions = [],
    menuItems,
    menuItemGroups
  } = params;
  const nodes = [];
  let keyOffset = 0;
  for (let i = 0; i < fieldActions.length; i += 1) {
    const a = fieldActions[i];
    nodes.push(mapFieldActionToPaneMenuNode(a, "".concat(i, "-").concat(a.type)));
  }
  keyOffset += nodes.length;
  const groups = [];
  for (const itemGroup of menuItemGroups) {
    const group = groups.find(g => g.key === itemGroup.id);
    if (!group) {
      groups.push({
        type: "group",
        key: itemGroup.id,
        children: [],
        expanded: true,
        renderAsButton: false,
        title: itemGroup.title
      });
    }
  }
  const ungroupedItems = [];
  for (let i = 0; i < menuItems.length; i += 1) {
    const item = menuItems[i];
    let group = item.group && groups.find(g => g.key === item.group);
    if (item.group && !group) {
      group = {
        type: "group",
        key: item.group,
        expanded: true,
        icon: item.icon,
        title: item.group,
        children: [],
        renderAsButton: false
      };
      groups.push(group);
    }
    if (group) {
      group.children.push({
        type: "item",
        key: "".concat(keyOffset + i, "-item"),
        hotkey: item.shortcut,
        icon: item.icon,
        onAction: () => params.actionHandler(item),
        renderAsButton: (_a = item.showAsAction) != null ? _a : false,
        selected: item.selected,
        title: item.title,
        tone: item.tone
      });
    } else {
      ungroupedItems.push({
        type: "item",
        key: "".concat(keyOffset + i, "-item"),
        hotkey: item.shortcut,
        icon: item.icon,
        onAction: () => params.actionHandler(item),
        renderAsButton: (_b = item.showAsAction) != null ? _b : false,
        selected: item.selected,
        title: item.title,
        tone: item.tone
      });
    }
  }
  return [...ungroupedItems, ...groups, ...nodes];
}
function mapFieldActionToPaneMenuNode(a, key) {
  var _a, _b, _c;
  if (a.type === "divider") {
    return {
      type: "divider",
      key
    };
  }
  if (a.type === "group") {
    return {
      type: "group",
      key,
      children: a.children.map((child, childIdx) => mapFieldActionToPaneMenuNode(child, "".concat(key, "-").concat(childIdx, "-").concat(child.type))),
      disabled: a.disabled,
      expanded: (_a = a.expanded) != null ? _a : true,
      icon: a.icon,
      title: a.title,
      renderAsButton: (_b = a.renderAsButton) != null ? _b : false
    };
  }
  return {
    type: "item",
    key,
    disabled: a.disabled,
    icon: a.icon,
    iconRight: a.iconRight,
    onAction: a.onAction,
    renderAsButton: (_c = a.renderAsButton) != null ? _c : false,
    selected: a.selected,
    title: a.title,
    tone: a.tone
  };
}
const IntentButton = forwardRef(function IntentButton2(props, ref) {
  const {
    intent,
    ...restProps
  } = props;
  const Link = useMemo(() =>
  // eslint-disable-next-line @typescript-eslint/no-shadow
  forwardRef(function Link2(linkProps, linkRef) {
    return /* @__PURE__ */jsx(IntentLink, {
      ...linkProps,
      intent: intent.type,
      params: intent.params,
      ref: linkRef
    });
  }), [intent]);
  return props.disabled ? /* @__PURE__ */jsx(Button, {
    ...props,
    as: "a",
    role: "link",
    "aria-disabled": "true"
  }) : /* @__PURE__ */jsx(Button, {
    ...restProps,
    as: Link,
    "data-as": "a",
    ref
  });
});
function InsufficientPermissionsMessageTooltip(_ref17) {
  let {
    reveal,
    loading,
    children
  } = _ref17;
  const currentUser = useCurrentUser();
  if (!reveal) {
    return /* @__PURE__ */jsx(Fragment, {
      children
    });
  }
  return /* @__PURE__ */jsx(Tooltip, {
    content: loading ? /* @__PURE__ */jsx(Box, {
      padding: 2,
      children: /* @__PURE__ */jsx(Text, {
        children: "Loading\u2026"
      })
    }) : /* @__PURE__ */jsx(InsufficientPermissionsMessage, {
      currentUser
    }),
    portal: true,
    children: /* @__PURE__ */jsx("div", {
      children
    })
  });
}
const POPOVER_PROPS = {
  constrainSize: true,
  placement: "bottom",
  portal: true
};
const getIntent = (schema, templates, item) => {
  var _a;
  const typeName = (_a = templates.find(t => t.id === item.templateId)) == null ? void 0 : _a.schemaType;
  if (!typeName) return null;
  const baseParams = {
    template: item.templateId,
    type: typeName,
    id: item.initialDocumentId
  };
  return {
    type: "create",
    params: item.parameters ? [baseParams, item.parameters] : baseParams
  };
};
function PaneHeaderCreateButton(_ref18) {
  let {
    templateItems
  } = _ref18;
  const schema = useSchema();
  const templates = useTemplates();
  const [templatePermissions, isTemplatePermissionsLoading] = useTemplatePermissions({
    templateItems
  });
  const nothingGranted = useMemo(() => {
    return !isTemplatePermissionsLoading && (templatePermissions == null ? void 0 : templatePermissions.every(permission => !permission.granted));
  }, [isTemplatePermissionsLoading, templatePermissions]);
  const permissionsById = useMemo(() => {
    if (!templatePermissions) return {};
    return templatePermissions.reduce((acc, permission) => {
      acc[permission.id] = permission;
      return acc;
    }, {});
  }, [templatePermissions]);
  if (nothingGranted) {
    return /* @__PURE__ */jsx(InsufficientPermissionsMessageTooltip, {
      reveal: true,
      loading: isTemplatePermissionsLoading,
      children: /* @__PURE__ */jsx(Button, {
        "aria-label": "Insufficient permissions",
        icon: ComposeIcon,
        mode: "bleed",
        disabled: true,
        "data-testid": "action-intent-button"
      })
    });
  }
  if (templateItems.length === 1) {
    const firstItem = templateItems[0];
    const permissions = permissionsById[firstItem.id];
    const disabled = !(permissions == null ? void 0 : permissions.granted);
    const intent = getIntent(schema, templates, firstItem);
    if (!intent) return null;
    return /* @__PURE__ */jsx(InsufficientPermissionsMessageTooltip, {
      reveal: disabled,
      loading: isTemplatePermissionsLoading,
      children: /* @__PURE__ */jsx(IntentButton, {
        "aria-label": firstItem.title,
        icon: firstItem.icon || ComposeIcon,
        intent,
        mode: "bleed",
        disabled,
        "data-testid": "action-intent-button"
      })
    });
  }
  return /* @__PURE__ */jsx(MenuButton, {
    button: /* @__PURE__ */jsx(Button, {
      icon: ComposeIcon,
      mode: "bleed",
      "data-testid": "multi-action-intent-button"
    }),
    id: "create-menu",
    menu: /* @__PURE__ */jsxs(Menu, {
      children: [/* @__PURE__ */jsx(Box, {
        paddingX: 3,
        paddingTop: 3,
        paddingBottom: 2,
        children: /* @__PURE__ */jsx(Label, {
          muted: true,
          children: "Create"
        })
      }), templateItems.map((item, itemIndex) => {
        const permissions = permissionsById[item.id];
        const disabled = !(permissions == null ? void 0 : permissions.granted);
        const intent = getIntent(schema, templates, item);
        const template = templates.find(t => t.id === item.templateId);
        if (!template || !intent) return null;
        const Link = forwardRef((linkProps, linkRef) => disabled ? /* @__PURE__ */jsx("button", {
          type: "button",
          disabled: true,
          ...linkProps,
          ref: linkRef
        }) : /* @__PURE__ */jsx(IntentLink, {
          ...linkProps,
          intent: intent.type,
          params: intent.params,
          ref: linkRef
        }));
        Link.displayName = "Link";
        return /* @__PURE__ */jsx(InsufficientPermissionsMessageTooltip, {
          reveal: disabled,
          loading: isTemplatePermissionsLoading,
          children: /* @__PURE__ */jsx(MenuItem, {
            as: Link,
            "data-as": disabled ? "button" : "a",
            text: item.title || template.title,
            "aria-label": disabled ? "Insufficient permissions" : item.title || template.title,
            disabled,
            "data-testid": "action-intent-button-".concat(itemIndex)
          })
        }, item.id);
      })]
    }),
    popover: POPOVER_PROPS
  });
}
function isNonNullable(value) {
  return value !== null && value !== void 0;
}
const hashObject = value => {
  const sortObject = v => {
    if (typeof v !== "object" || !v) return v;
    if (Array.isArray(v)) return v.map(sortObject);
    return Object.entries(v).sort((_ref19, _ref20) => {
      let [keyA] = _ref19;
      let [keyB] = _ref20;
      return keyA.localeCompare(keyB, "en");
    });
  };
  const normalize = v => JSON.parse(JSON.stringify(v));
  return JSON.stringify(sortObject(normalize(value)));
};
const PaneHeaderActions = memo(function PaneHeaderActions2(props) {
  const {
    initialValueTemplateItems: initialValueTemplateItemsFromStructure = EMPTY_ARRAY$1,
    menuItems = EMPTY_ARRAY$1,
    menuItemGroups = EMPTY_ARRAY$1,
    actionHandlers = EMPTY_OBJECT
  } = props;
  const templates = useTemplates();
  const handleAction = useCallback(item => {
    if (typeof item.action === "string" && !(item.action in actionHandlers)) {
      console.warn("No handler for action:", item.action);
      return false;
    }
    const handler =
    // eslint-disable-next-line no-nested-ternary
    typeof item.action === "function" ? item.action : typeof item.action === "string" ? actionHandlers[item.action] : null;
    if (handler) {
      handler(item.params);
      return true;
    }
    return false;
  }, [actionHandlers]);
  const menuNodes = useMemo(() => resolveMenuNodes({
    actionHandler: handleAction,
    menuItemGroups,
    menuItems: menuItems.filter(item => {
      var _a;
      return ((_a = item.intent) == null ? void 0 : _a.type) !== "create";
    })
  }), [handleAction, menuItemGroups, menuItems]);
  const actionNodes = useMemo(() => menuNodes.filter(isMenuNodeButton), [menuNodes]);
  const contextMenuNodes = useMemo(() => menuNodes.filter(isNotMenuNodeButton), [menuNodes]);
  const initialValueTemplateItemFromMenuItems = useMemo(() => {
    return menuItems.map((item, menuItemIndex) => {
      var _a;
      if (((_a = item.intent) == null ? void 0 : _a.type) !== "create") return null;
      const {
        params
      } = item.intent;
      if (!params) return null;
      const intentParams = Array.isArray(params) ? params[0] : params;
      const templateParams = Array.isArray(params) ? params[1] : void 0;
      const templateId = intentParams.template || intentParams.type;
      if (!templateId) return null;
      const template = templates.find(t => t.id === templateId);
      if (!template) return null;
      const initialDocumentId = intentParams.id;
      return {
        item,
        template,
        templateParams,
        menuItemIndex,
        initialDocumentId
      };
    }).filter(isNonNullable).map(_ref21 => {
      let {
        initialDocumentId,
        item,
        template,
        menuItemIndex,
        templateParams
      } = _ref21;
      const initialValueTemplateItem = {
        id: "menuItem".concat(menuItemIndex),
        initialDocumentId,
        templateId: template.id,
        type: "initialValueTemplateItem",
        title: item.title || template.title,
        icon: item.icon,
        description: template.description,
        parameters: templateParams,
        schemaType: template.schemaType
      };
      return initialValueTemplateItem;
    });
  }, [menuItems, templates]);
  const combinedInitialValueTemplates = useMemo(() => {
    return uniqBy([...initialValueTemplateItemFromMenuItems, ...initialValueTemplateItemsFromStructure], item => hashObject([item.initialDocumentId, item.templateId, item.parameters]));
  }, [initialValueTemplateItemFromMenuItems, initialValueTemplateItemsFromStructure]);
  return /* @__PURE__ */jsxs(Flex, {
    gap: 1,
    children: [combinedInitialValueTemplates.length > 0 && /* @__PURE__ */jsx(PaneHeaderCreateButton, {
      templateItems: combinedInitialValueTemplates
    }), actionNodes.map(node => /* @__PURE__ */jsx(PaneHeaderActionButton, {
      node
    }, node.key)), contextMenuNodes.length > 0 && /* @__PURE__ */jsx(PaneContextMenuButton, {
      nodes: contextMenuNodes
    })]
  });
});
const DISABLED_REASON_TITLE$4 = {
  NOTHING_TO_DELETE: "This document doesn\u2019t yet exist or is already deleted"
};
const DeleteAction = _ref22 => {
  let {
    id,
    type,
    draft,
    onComplete
  } = _ref22;
  const {
    delete: deleteOp
  } = useDocumentOperation(id, type);
  const [isDeleting, setIsDeleting] = useState(false);
  const [isConfirmDialogOpen, setConfirmDialogOpen] = useState(false);
  const handleCancel = useCallback(() => {
    setConfirmDialogOpen(false);
    onComplete();
  }, [onComplete]);
  const handleConfirm = useCallback(() => {
    setIsDeleting(true);
    setConfirmDialogOpen(false);
    deleteOp.execute();
    onComplete();
  }, [deleteOp, onComplete]);
  const handle = useCallback(() => {
    setConfirmDialogOpen(true);
  }, []);
  const [permissions, isPermissionsLoading] = useDocumentPairPermissions({
    id,
    type,
    permission: "delete"
  });
  const currentUser = useCurrentUser();
  if (!isPermissionsLoading && !(permissions == null ? void 0 : permissions.granted)) {
    return {
      tone: "critical",
      icon: TrashIcon,
      disabled: true,
      label: "Delete",
      title: /* @__PURE__ */jsx(InsufficientPermissionsMessage, {
        operationLabel: "delete this document",
        currentUser
      })
    };
  }
  return {
    tone: "critical",
    icon: TrashIcon,
    disabled: isDeleting || Boolean(deleteOp.disabled) || isPermissionsLoading,
    title: deleteOp.disabled && DISABLED_REASON_TITLE$4[deleteOp.disabled] || "",
    label: isDeleting ? "Deleting\u2026" : "Delete",
    shortcut: "Ctrl+Alt+D",
    onHandle: handle,
    dialog: isConfirmDialogOpen && {
      type: "custom",
      component: /* @__PURE__ */jsx(ConfirmDeleteDialogContainer, {
        action: "delete",
        id: (draft == null ? void 0 : draft._id) || id,
        type,
        onCancel: handleCancel,
        onConfirm: handleConfirm
      })
    }
  };
};
DeleteAction.action = "delete";
const DISABLED_REASON_TITLE$3 = {
  NO_CHANGES: "This document has no unpublished changes",
  NOT_PUBLISHED: "This document is not published"
};
const DiscardChangesAction = _ref23 => {
  let {
    id,
    type,
    published,
    liveEdit,
    onComplete
  } = _ref23;
  const {
    discardChanges
  } = useDocumentOperation(id, type);
  const [isConfirmDialogOpen, setConfirmDialogOpen] = useState(false);
  const [permissions, isPermissionsLoading] = useDocumentPairPermissions({
    id,
    type,
    permission: "discardDraft"
  });
  const currentUser = useCurrentUser();
  const handleConfirm = useCallback(() => {
    discardChanges.execute();
    onComplete();
  }, [discardChanges, onComplete]);
  const handle = useCallback(() => {
    setConfirmDialogOpen(true);
  }, []);
  const dialog = useMemo(() => isConfirmDialogOpen && {
    type: "confirm",
    tone: "critical",
    onCancel: onComplete,
    onConfirm: handleConfirm,
    message: /* @__PURE__ */jsx(Fragment, {
      children: "Are you sure you want to discard all changes since last published?"
    })
  }, [handleConfirm, isConfirmDialogOpen, onComplete]);
  if (!published || liveEdit) {
    return null;
  }
  if (!isPermissionsLoading && !(permissions == null ? void 0 : permissions.granted)) {
    return {
      tone: "critical",
      icon: ResetIcon,
      disabled: true,
      label: "Discard changes",
      title: /* @__PURE__ */jsx(InsufficientPermissionsMessage, {
        operationLabel: "discard changes in this document",
        currentUser
      })
    };
  }
  return {
    tone: "critical",
    icon: ResetIcon,
    disabled: Boolean(discardChanges.disabled) || isPermissionsLoading,
    title: discardChanges.disabled && DISABLED_REASON_TITLE$3[discardChanges.disabled] || "",
    label: "Discard changes",
    onHandle: handle,
    dialog
  };
};
DiscardChangesAction.action = "discardChanges";
const DISABLED_REASON_TITLE$2 = {
  NOTHING_TO_DUPLICATE: "This document doesn\u2019t yet exist so there\u2018s nothing to duplicate"
};
const DuplicateAction = _ref24 => {
  let {
    id,
    type,
    onComplete
  } = _ref24;
  const {
    duplicate
  } = useDocumentOperation(id, type);
  const {
    navigateIntent
  } = useRouter();
  const [isDuplicating, setDuplicating] = useState(false);
  const [permissions, isPermissionsLoading] = useDocumentPairPermissions({
    id,
    type,
    permission: "duplicate"
  });
  const currentUser = useCurrentUser();
  const handle = useCallback(() => {
    const dupeId = uuid();
    setDuplicating(true);
    duplicate.execute(dupeId);
    navigateIntent("edit", {
      id: dupeId,
      type
    });
    onComplete();
  }, [duplicate, navigateIntent, onComplete, type]);
  if (!isPermissionsLoading && !(permissions == null ? void 0 : permissions.granted)) {
    return {
      icon: CopyIcon,
      disabled: true,
      label: "Duplicate",
      title: /* @__PURE__ */jsx(InsufficientPermissionsMessage, {
        operationLabel: "duplicate this document",
        currentUser
      })
    };
  }
  return {
    icon: CopyIcon,
    disabled: isDuplicating || Boolean(duplicate.disabled) || isPermissionsLoading,
    label: isDuplicating ? "Duplicating\u2026" : "Duplicate",
    title: duplicate.disabled && DISABLED_REASON_TITLE$2[duplicate.disabled] || "",
    onHandle: handle
  };
};
DuplicateAction.action = "duplicate";
const HistoryRestoreAction = _ref25 => {
  let {
    id,
    type,
    revision,
    onComplete
  } = _ref25;
  const {
    restore
  } = useDocumentOperation(id, type);
  const {
    navigateIntent
  } = useRouter();
  const [isConfirmDialogOpen, setConfirmDialogOpen] = useState(false);
  const handleConfirm = useCallback(() => {
    restore.execute(revision);
    navigateIntent("edit", {
      id,
      type
    });
    onComplete();
  }, [restore, revision, navigateIntent, id, type, onComplete]);
  const handle = useCallback(() => {
    setConfirmDialogOpen(true);
  }, []);
  const dialog = useMemo(() => {
    if (isConfirmDialogOpen) {
      return {
        type: "confirm",
        tone: "critical",
        onCancel: onComplete,
        onConfirm: handleConfirm,
        message: /* @__PURE__ */jsx(Fragment, {
          children: "Are you sure you want to restore this document?"
        })
      };
    }
    return null;
  }, [handleConfirm, isConfirmDialogOpen, onComplete]);
  const isRevisionInitialVersion = revision === "@initial";
  const isRevisionLatestVersion = revision === void 0;
  if (isRevisionLatestVersion) {
    return null;
  }
  return {
    label: "Restore",
    color: "primary",
    onHandle: handle,
    title: isRevisionInitialVersion ? "You can't restore to the initial version" : "Restore to this version",
    icon: RestoreIcon,
    dialog,
    disabled: isRevisionInitialVersion
  };
};
HistoryRestoreAction.action = "restore";
const DocumentPaneContext = createContext(null);
function useDocumentPane() {
  const documentPane = useContext(DocumentPaneContext);
  if (!documentPane) {
    throw new Error("DocumentPane: missing context value");
  }
  return documentPane;
}
const DISABLED_REASON_TITLE$1 = {
  LIVE_EDIT_ENABLED: "Cannot publish since liveEdit is enabled for this document type",
  ALREADY_PUBLISHED: "Already published",
  NO_CHANGES: "No unpublished changes",
  NOT_READY: "Operation not ready"
};
function getDisabledReason(reason, publishedAt) {
  if (reason === "ALREADY_PUBLISHED" && publishedAt) {
    return /* @__PURE__ */jsx(Fragment, {
      children: /* @__PURE__ */jsxs("span", {
        children: ["Published ", /* @__PURE__ */jsx(TimeAgo, {
          time: publishedAt
        })]
      })
    });
  }
  return DISABLED_REASON_TITLE$1[reason];
}
const PublishAction = props => {
  var _a;
  const {
    id,
    type,
    liveEdit,
    draft,
    published
  } = props;
  const [publishState, setPublishState] = useState(null);
  const {
    publish
  } = useDocumentOperation(id, type);
  const validationStatus = useValidationStatus(id, type);
  const syncState = useSyncState(id, type);
  const {
    changesOpen,
    onHistoryOpen,
    documentId,
    documentType
  } = useDocumentPane();
  const editState = useEditState(documentId, documentType);
  const revision = ((editState == null ? void 0 : editState.draft) || (editState == null ? void 0 : editState.published) || {})._rev;
  const hasValidationErrors = validationStatus.validation.some(isValidationErrorMarker);
  const [publishScheduled, setPublishScheduled] = useState(false);
  const isSyncing = syncState.isSyncing;
  const isValidating = validationStatus.isValidating;
  const [permissions, isPermissionsLoading] = useDocumentPairPermissions({
    id,
    type,
    permission: "publish"
  });
  const currentUser = useCurrentUser();
  const title = publish.disabled ? getDisabledReason(publish.disabled, (published || {})._updatedAt) || "" : hasValidationErrors ? "There are validation errors that need to be fixed before this document can be published" : "";
  const hasDraft = Boolean(draft);
  const doPublish = useCallback(() => {
    publish.execute();
    setPublishState("publishing");
  }, [publish]);
  useEffect(() => {
    const validationComplete = validationStatus.isValidating === false && validationStatus.revision !== revision;
    if (!publishScheduled || isSyncing || !validationComplete) {
      return;
    }
    if (!hasValidationErrors) {
      doPublish();
    }
    setPublishScheduled(false);
  }, [isSyncing, doPublish, hasValidationErrors, publishScheduled, validationStatus.revision, revision, isValidating, validationStatus.isValidating]);
  useEffect(() => {
    const didPublish = publishState === "publishing" && !hasDraft;
    if (didPublish) {
      if (changesOpen) {
        onHistoryOpen();
      }
    }
    const nextState = didPublish ? "published" : null;
    const delay = didPublish ? 200 : 4e3;
    const timer = setTimeout(() => {
      setPublishState(nextState);
    }, delay);
    return () => clearTimeout(timer);
  }, [changesOpen, publishState, hasDraft, onHistoryOpen]);
  const handle = useCallback(() => {
    if (syncState.isSyncing || validationStatus.isValidating || validationStatus.revision !== revision) {
      setPublishScheduled(true);
    } else {
      doPublish();
    }
  }, [syncState.isSyncing, validationStatus.isValidating, validationStatus.revision, revision, doPublish]);
  if (liveEdit) {
    return {
      tone: "positive",
      label: "Publish",
      title: "Live Edit is enabled for this content type and publishing happens automatically as you make changes",
      disabled: true
    };
  }
  if (!isPermissionsLoading && !(permissions == null ? void 0 : permissions.granted)) {
    return {
      tone: "positive",
      label: "Publish",
      title: /* @__PURE__ */jsx(InsufficientPermissionsMessage, {
        operationLabel: "publish this document",
        currentUser
      }),
      disabled: true
    };
  }
  const disabled = Boolean(publishScheduled || ((_a = editState == null ? void 0 : editState.transactionSyncLock) == null ? void 0 : _a.enabled) || publishState === "publishing" || publishState === "published" || hasValidationErrors || publish.disabled);
  return {
    disabled: disabled || isPermissionsLoading,
    tone: "positive",
    label:
    // eslint-disable-next-line no-nested-ternary
    publishState === "published" ? "Published" : publishScheduled || publishState === "publishing" ? "Publishing\u2026" : "Publish",
    // @todo: Implement loading state, to show a `<Button loading />` state
    // loading: publishScheduled || publishState === 'publishing',
    icon: publishState === "published" ? CheckmarkIcon : PublishIcon,
    // eslint-disable-next-line no-nested-ternary
    title: publishScheduled ? "Waiting for tasks to finish before publishing" : publishState === "published" || publishState === "publishing" ? null : title,
    shortcut: disabled || publishScheduled ? null : "Ctrl+Alt+P",
    onHandle: handle
  };
};
PublishAction.action = "publish";
const DISABLED_REASON_TITLE = {
  NOT_PUBLISHED: "This document is not published"
};
const UnpublishAction = _ref26 => {
  let {
    id,
    type,
    draft,
    onComplete,
    liveEdit
  } = _ref26;
  const {
    unpublish
  } = useDocumentOperation(id, type);
  const [isConfirmDialogOpen, setConfirmDialogOpen] = useState(false);
  const [permissions, isPermissionsLoading] = useDocumentPairPermissions({
    id,
    type,
    permission: "unpublish"
  });
  const currentUser = useCurrentUser();
  const handleCancel = useCallback(() => {
    setConfirmDialogOpen(false);
    onComplete();
  }, [onComplete]);
  const handleConfirm = useCallback(() => {
    setConfirmDialogOpen(false);
    unpublish.execute();
    onComplete();
  }, [onComplete, unpublish]);
  const dialog = useMemo(() => {
    if (isConfirmDialogOpen) {
      return {
        type: "dialog",
        onClose: onComplete,
        content: /* @__PURE__ */jsx(ConfirmDeleteDialogContainer, {
          id: (draft == null ? void 0 : draft._id) || id,
          type,
          action: "unpublish",
          onCancel: handleCancel,
          onConfirm: handleConfirm
        })
      };
    }
    return null;
  }, [draft, id, handleCancel, handleConfirm, isConfirmDialogOpen, onComplete, type]);
  if (liveEdit) {
    return null;
  }
  if (!isPermissionsLoading && !(permissions == null ? void 0 : permissions.granted)) {
    return {
      tone: "critical",
      icon: UnpublishIcon,
      label: "Unpublish",
      title: /* @__PURE__ */jsx(InsufficientPermissionsMessage, {
        operationLabel: "unpublish this document",
        currentUser
      }),
      disabled: true
    };
  }
  return {
    tone: "critical",
    icon: UnpublishIcon,
    disabled: Boolean(unpublish.disabled) || isPermissionsLoading,
    label: "Unpublish",
    title: unpublish.disabled ? DISABLED_REASON_TITLE[unpublish.disabled] : "",
    onHandle: () => setConfirmDialogOpen(true),
    dialog
  };
};
UnpublishAction.action = "unpublish";
const LiveEditBadge = props => {
  const {
    liveEdit
  } = props;
  if (liveEdit) {
    return {
      label: "Live",
      color: "danger"
    };
  }
  return null;
};
const _DEBUG = false;
const EMPTY_PARAMS$2 = {};
const LOADING_PANE = Symbol("LOADING_PANE");
const DOCUMENT_PANEL_PORTAL_ELEMENT = "documentPanelPortalElement";
const state = {
  activePanes: []
};
function setActivePanes(panes) {
  state.activePanes = panes;
}
function getIntentState(intent, params, routerState, payload) {
  var _a;
  const panes = (routerState == null ? void 0 : routerState.panes) || [];
  const activePanes = state.activePanes || [];
  const editDocumentId = params.id || uuid();
  const isTemplate = intent === "create" && params.template;
  for (let i = activePanes.length - 1; i >= 0; i--) {
    const pane = activePanes[i];
    if (typeof pane !== "object") continue;
    if (((_a = pane.canHandleIntent) == null ? void 0 : _a.call(pane, intent, params, {
      pane,
      index: i
    })) ||
    // see `resolveIntent.ts` for more info
    pane.type === "documentList" && pane.schemaTypeName === params.type && pane.options.filter === "_type == $type") {
      const paneParams = isTemplate ? {
        template: params.template
      } : EMPTY_PARAMS$2;
      return {
        panes: panes.slice(0, i).concat([[{
          id: editDocumentId,
          params: paneParams,
          payload
        }]])
      };
    }
  }
  return {
    intent,
    params,
    payload
  };
}
const EMPTY_PARAMS$1 = {};
function legacyEditParamsToState(params) {
  try {
    return JSON.parse(decodeURIComponent(params));
  } catch (err) {
    console.warn("Failed to parse JSON parameters");
    return {};
  }
}
function encodePanesSegment(panes) {
  return (panes || []).map(group => group.map(encodeChunks).join("|")).map(encodeURIComponent).join(";");
}
function legacyEditParamsToPath(params) {
  return JSON.stringify(params);
}
function toState(pathSegment) {
  return parsePanesSegment(decodeURIComponent(pathSegment));
}
function toPath(panes) {
  return encodePanesSegment(panes);
}
const router = route.create("/", [
// "Asynchronous intent resolving" route
route.intents("/intent"),
// Legacy fallback route, will be redirected to new format
route.create("/edit/:type/:editDocumentId", [route.create({
  path: "/:params",
  transform: {
    params: {
      toState: legacyEditParamsToState,
      toPath: legacyEditParamsToPath
    }
  }
})]),
// The regular path - when the intent can be resolved to a specific pane
route.create({
  path: "/:panes",
  // Legacy URLs, used to handle redirects
  children: [route.create("/:action", route.create("/:legacyEditDocumentId"))],
  transform: {
    panes: {
      toState,
      toPath
    }
  }
})]);
const panePattern = /^([.a-z0-9_-]+),?({.*?})?(?:(;|$))/i;
const isParam = str => /^[a-z0-9]+=[^=]+/i.test(str);
const isPayload = str => /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(str);
const exclusiveParams = ["view", "since", "rev", "inspect"];
const isTruthy = Boolean;
function parseChunks(chunks, initial) {
  return chunks.reduce((pane, chunk) => {
    if (isParam(chunk)) {
      const key = chunk.slice(0, chunk.indexOf("="));
      const value = chunk.slice(key.length + 1);
      pane.params = {
        ...pane.params,
        [decodeURIComponent(key)]: decodeURIComponent(value)
      };
    } else if (isPayload(chunk)) {
      pane.payload = tryParseBase64Payload(chunk);
    } else {
      console.warn("Unknown pane segment: %s - skipping", chunk);
    }
    return pane;
  }, {
    ...initial,
    params: EMPTY_PARAMS$1,
    payload: void 0
  });
}
function encodeChunks(pane, index, group) {
  const {
    payload,
    params = {},
    id
  } = pane;
  const [firstSibling] = group;
  const paneIsFirstSibling = pane === firstSibling;
  const sameAsFirst = index !== 0 && id === firstSibling.id;
  const encodedPayload = typeof payload === "undefined" ? void 0 : btoa(JSON.stringify(payload));
  const encodedParams = Object.entries(params).filter(entry => {
    var _a;
    const [key, value] = entry;
    if (!value) return false;
    if (paneIsFirstSibling) return true;
    const valueFromFirstSibling = (_a = firstSibling.params) == null ? void 0 : _a[key];
    if (value === valueFromFirstSibling && !exclusiveParams.includes(key)) return false;
    return true;
  }).map(_ref27 => {
    let [key, value] = _ref27;
    return "".concat(encodeURIComponent(key), "=").concat(encodeURIComponent(value));
  });
  return [sameAsFirst ? "" : id].concat([encodedParams.length > 0 && encodedParams, encodedPayload].filter(isTruthy).flat()).join(",") || ",";
}
function parsePanesSegment(str) {
  if (str.indexOf(",{") !== -1) {
    return parseOldPanesSegment(str);
  }
  return str.split(";").map(group => {
    const [firstSibling, ...restOfSiblings] = group.split("|").map(segment => {
      const [id, ...chunks] = segment.split(",");
      return parseChunks(chunks, {
        id
      });
    });
    return [firstSibling, ...restOfSiblings.map(sibling => ({
      ...firstSibling,
      ...sibling,
      id: sibling.id || firstSibling.id,
      params: {
        ...omit(firstSibling.params, exclusiveParams),
        ...sibling.params
      },
      payload: sibling.payload || firstSibling.payload
    }))];
  }).filter(group => group.length > 0);
}
function parseOldPanesSegment(str) {
  const chunks = [];
  let buffer = str;
  while (buffer.length) {
    const [match, id, payloadChunk] = buffer.match(panePattern) || [];
    if (!match) {
      buffer = buffer.slice(1);
      continue;
    }
    const payload = payloadChunk && tryParsePayload(payloadChunk);
    chunks.push({
      id,
      payload
    });
    buffer = buffer.slice(match.length);
  }
  return [chunks];
}
function tryParsePayload(json) {
  try {
    return JSON.parse(json);
  } catch (err) {
    console.warn("Failed to parse parameters: ".concat(err.message));
    return void 0;
  }
}
function tryParseBase64Payload(data) {
  return data ? tryParsePayload(atob(data)) : void 0;
}
const DOCUMENT_PANEL_MIN_WIDTH = 320;
const DOCUMENT_PANEL_INITIAL_MIN_WIDTH = 600;
const DOCUMENT_INSPECTOR_MIN_WIDTH = 320;
const DOCUMENT_INSPECTOR_MAX_WIDTH = 540;
const EMPTY_PARAMS = {};
const INSPECT_ACTION_PREFIX = "inspect:";
const DEFAULT_MENU_ITEM_GROUPS = [{
  id: "inspectors"
}, {
  id: "links"
}];
const HISTORY_INSPECTOR_NAME = "sanity/desk/history";
const VALIDATION_INSPECTOR_NAME = "sanity/desk/validation";
const Root$5 = styled(Card)({
  position: "relative",
  zIndex: 1,
  lineHeight: 0,
  "&:after": {
    content: '""',
    display: "block",
    position: "absolute",
    left: 0,
    bottom: -1,
    right: 0,
    borderBottom: "1px solid var(--card-border-color)",
    opacity: 0.5
  }
});
function DocumentInspectorHeader(props) {
  const {
    as: forwardedAs,
    children,
    closeButtonLabel,
    onClose,
    title,
    ...restProps
  } = props;
  return /* @__PURE__ */jsxs(Root$5, {
    ...restProps,
    as: forwardedAs,
    children: [/* @__PURE__ */jsxs(Flex, {
      padding: 2,
      children: [/* @__PURE__ */jsx(Box, {
        flex: 1,
        padding: 3,
        children: /* @__PURE__ */jsx(Text, {
          as: "h1",
          size: 1,
          weight: "semibold",
          children: title
        })
      }), /* @__PURE__ */jsx(Box, {
        flex: "none",
        padding: 1,
        children: /* @__PURE__ */jsx(Button, {
          "aria-label": closeButtonLabel,
          fontSize: 1,
          icon: CloseIcon,
          mode: "bleed",
          onClick: onClose,
          padding: 2
        })
      })]
    }), children]
  });
}
const DeskToolContext = createContext(null);
function useDeskTool() {
  const deskTool = useContext(DeskToolContext);
  if (!deskTool) throw new Error("DeskTool: missing context value");
  return deskTool;
}
const Root$4 = styled.div(_templateObject22 || (_templateObject22 = _taggedTemplateLiteral(["\n  position: absolute;\n  top: 0;\n  left: -4px;\n  bottom: 0;\n  width: 9px;\n  z-index: 201;\n  cursor: ew-resize;\n\n  /* Border */\n  & > span:nth-child(1) {\n    display: block;\n    border-left: 1px solid var(--card-border-color);\n    position: absolute;\n    top: 0;\n    left: 4px;\n    bottom: 0;\n    transition: opacity 200ms;\n    opacity: 0.5;\n  }\n\n  /* Hover effect */\n  & > span:nth-child(2) {\n    display: block;\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 9px;\n    bottom: 0;\n    background-color: var(--card-border-color);\n    opacity: 0;\n    transition: opacity 150ms;\n  }\n\n  @media (hover: hover) {\n    &:hover > span:nth-child(2) {\n      opacity: 0.2;\n    }\n  }\n"])));
function Resizer(props) {
  const {
    onResize,
    onResizeStart
  } = props;
  const mouseXRef = useRef(0);
  const handleMouseDown = useCallback(event => {
    event.preventDefault();
    mouseXRef.current = event.pageX;
    onResizeStart();
    const handleMouseMove = e => {
      e.preventDefault();
      onResize(e.pageX - mouseXRef.current);
    };
    const handleMouseUp = () => {
      window.removeEventListener("mousemove", handleMouseMove);
      window.removeEventListener("mouseup", handleMouseUp);
    };
    window.addEventListener("mousemove", handleMouseMove);
    window.addEventListener("mouseup", handleMouseUp);
  }, [onResize, onResizeStart]);
  return /* @__PURE__ */jsxs(Root$4, {
    onMouseDown: handleMouseDown,
    children: [/* @__PURE__ */jsx("span", {}), /* @__PURE__ */jsx("span", {})]
  });
}
const Root$3 = styled(Box)(_templateObject23 || (_templateObject23 = _taggedTemplateLiteral(["\n  position: relative;\n  flex: 1;\n  padding-left: 1px;\n"])));
function Resizable(props) {
  const {
    as: forwardedAs,
    children,
    minWidth,
    maxWidth,
    ...restProps
  } = props;
  const [element, setElement] = useState(null);
  const elementWidthRef = useRef();
  const [targetWidth, setTargetWidth] = useState();
  const handleResizeStart = useCallback(() => {
    elementWidthRef.current = element == null ? void 0 : element.offsetWidth;
  }, [element]);
  const handleResize = useCallback(deltaX => {
    const w = elementWidthRef.current;
    if (!w) return;
    setTargetWidth(Math.min(Math.max(w - deltaX, minWidth), maxWidth));
  }, [minWidth, maxWidth]);
  const style = useMemo(() => targetWidth ? {
    flex: "none",
    width: targetWidth
  } : {
    minWidth,
    maxWidth
  }, [minWidth, maxWidth, targetWidth]);
  return /* @__PURE__ */jsxs(Root$3, {
    as: forwardedAs,
    ...restProps,
    ref: setElement,
    style,
    children: [children, /* @__PURE__ */jsx(Resizer, {
      onResize: handleResize,
      onResizeStart: handleResizeStart
    })]
  });
}
function getPathTypes(options) {
  const {
    path,
    schemaType,
    value
  } = options;
  const result = [];
  let s = schemaType;
  let v = value;
  for (const segment of path) {
    if (typeof segment === "string") {
      if (!isRecord(v) && v !== void 0) {
        throw new Error("Parent value is not an object, cannot get path segment: .".concat(segment));
      }
      if (s.jsonType !== "object") {
        throw new Error("Parent type is not an object schema type, cannot get path segment: .".concat(segment));
      }
      v = v == null ? void 0 : v[segment];
      const field = s.fields.find(f => f.name === segment);
      if (!field) {
        throw new Error("Field type not found: .".concat(segment));
      }
      s = field.type;
      result.push(s);
      continue;
    }
    if (typeof segment === "number") {
      if (!isArray(v) && v !== void 0) {
        throw new Error("Parent value is not an array, cannot get path segment: [".concat(segment, "]"));
      }
      if (s.jsonType !== "array") {
        throw new Error("Parent type is not an array schema type, cannot get path segment: [".concat(segment, "]"));
      }
      v = v == null ? void 0 : v[segment];
      const itemType = s.of.find(ofType => {
        if (typeof v === "string") {
          return ofType.jsonType === "string";
        }
        if (typeof v === "number") {
          return ofType.jsonType === "number";
        }
        if (typeof v === "boolean") {
          return ofType.jsonType === "boolean";
        }
        if (isRecord(v)) {
          return ofType.name === (v == null ? void 0 : v._type);
        }
        return false;
      });
      if (!itemType) {
        throw new Error("Item type not found: [".concat(segment, "]"));
      }
      s = itemType;
      result.push(s);
      continue;
    }
    if (isRecord(segment) && segment._key) {
      if (!isArray(v)) {
        throw new Error("Parent value is not an anrray, cannot get path segment: [_key == ".concat(segment, "]"));
      }
      if (s.jsonType !== "array") {
        throw new Error("Parent type is not an array schema type, cannot get path segment: .".concat(segment));
      }
      const values = v != null ? v : [];
      v = values.find(i => isRecord(i) && i._key === segment._key);
      if (!isRecord(v)) {
        throw new Error("Array item not found: [_key == ".concat(segment._key, "]"));
      }
      const ofType = s.of.find(i => isRecord(v) && i.name === (v == null ? void 0 : v._type));
      if (!ofType) {
        throw new Error("Array item type not found: .".concat(v == null ? void 0 : v._type));
      }
      s = ofType;
      result.push(s);
      continue;
    }
    throw new Error("Invalid path segment: ".concat(JSON.stringify(segment)));
  }
  return result;
}
const MARKER_ICON = {
  error: ErrorOutlineIcon,
  warning: WarningOutlineIcon,
  info: InfoOutlineIcon
};
const MARKER_TONE = {
  error: "critical",
  warning: "caution",
  info: "primary"
};
function ValidationInspector(props) {
  const {
    onClose
  } = props;
  const {
    onFocus,
    onPathOpen,
    schemaType,
    validation,
    value
  } = useDocumentPane();
  const handleOpen = useCallback(path => {
    onPathOpen(path);
    onFocus(path);
  }, [onFocus, onPathOpen]);
  return /* @__PURE__ */jsxs(Flex, {
    direction: "column",
    height: "fill",
    overflow: "hidden",
    children: [/* @__PURE__ */jsx(DocumentInspectorHeader, {
      as: "header",
      closeButtonLabel: "Close validation",
      flex: "none",
      onClose,
      title: "Validation"
    }), /* @__PURE__ */jsxs(Card, {
      flex: 1,
      overflow: "auto",
      padding: 3,
      children: [validation.length === 0 && /* @__PURE__ */jsx(Box, {
        padding: 2,
        children: /* @__PURE__ */jsx(Text, {
          muted: true,
          size: 1,
          children: "No validation errors"
        })
      }), validation.length > 0 && /* @__PURE__ */jsx(Stack, {
        space: 2,
        children: validation.map(marker => /* @__PURE__ */jsx(ValidationCard, {
          marker,
          onOpen: handleOpen,
          schemaType,
          value
        }, pathToString(marker.path)))
      })]
    })]
  });
}
function ValidationCard(props) {
  const {
    marker,
    onOpen,
    schemaType,
    value
  } = props;
  const handleOpen = useCallback(() => onOpen(marker.path), [marker, onOpen]);
  const [errorInfo, setErrorInfo] = useState(null);
  return /* @__PURE__ */jsxs(ErrorBoundary, {
    onCatch: setErrorInfo,
    children: [errorInfo && /* @__PURE__ */jsx(Card, {
      padding: 3,
      radius: 2,
      tone: "critical",
      children: /* @__PURE__ */jsxs(Text, {
        size: 1,
        children: ["ERROR: ", errorInfo.error.message]
      })
    }), !errorInfo && /* @__PURE__ */jsx(Card, {
      __unstable_focusRing: true,
      as: "button",
      onClick: handleOpen,
      padding: 3,
      radius: 2,
      tone: MARKER_TONE[marker.level],
      children: /* @__PURE__ */jsxs(Flex, {
        align: "flex-start",
        gap: 3,
        children: [/* @__PURE__ */jsx(Box, {
          flex: "none",
          children: /* @__PURE__ */jsx(Text, {
            size: 1,
            children: createElement(MARKER_ICON[marker.level])
          })
        }), /* @__PURE__ */jsxs(Stack, {
          flex: 1,
          space: 2,
          children: [/* @__PURE__ */jsx(DocumentNodePathBreadcrumbs, {
            path: marker.path,
            schemaType,
            value
          }), /* @__PURE__ */jsx(Text, {
            muted: true,
            size: 1,
            children: marker.item.message
          })]
        })]
      })
    })]
  });
}
function DocumentNodePathBreadcrumbs(props) {
  const {
    path,
    schemaType,
    value
  } = props;
  const pathTypes = useMemo(() => getPathTypes({
    path,
    schemaType,
    value
  }), [path, schemaType, value]);
  return /* @__PURE__ */jsx(Text, {
    size: 1,
    children: pathTypes.map((t, i) => /* @__PURE__ */jsxs(Fragment$1, {
      children: [i > 0 && /* @__PURE__ */jsx("span", {
        style: {
          color: "var(--card-muted-fg-color)",
          opacity: 0.5
        },
        children: " / "
      }), /* @__PURE__ */jsx("span", {
        style: {
          fontWeight: 500
        },
        children: t.title || t.name
      })]
    }, i))
  });
}
function useMenuItem(props) {
  const {
    documentId,
    documentType
  } = props;
  const {
    validation: validationMarkers
  } = useValidationStatus(documentId, documentType);
  const validation = useMemo(() => validationMarkers.map(item => ({
    level: item.level,
    message: item.item.message,
    path: item.path
  })), [validationMarkers]);
  const hasErrors = validation.some(isValidationError);
  const hasWarnings = validation.some(isValidationWarning);
  const icon = useMemo(() => {
    if (hasErrors) return ErrorOutlineIcon;
    if (hasWarnings) return WarningOutlineIcon;
    return CheckmarkCircleIcon;
  }, [hasErrors, hasWarnings]);
  const tone = useMemo(() => {
    if (hasErrors) return "critical";
    if (hasWarnings) return "caution";
    return "positive";
  }, [hasErrors, hasWarnings]);
  return {
    hidden: validation.length === 0,
    icon,
    title: "Validation",
    tone,
    showAsAction: true
  };
}
const validationInspector = {
  name: VALIDATION_INSPECTOR_NAME,
  component: ValidationInspector,
  useMenuItem
};
const TIMELINE_LABELS = {
  create: "created",
  delete: "deleted",
  discardDraft: "discarded draft",
  initial: "created",
  editDraft: "edited",
  editLive: "live edited",
  publish: "published",
  unpublish: "unpublished"
};
const TIMELINE_ICON_COMPONENTS = {
  create: AddCircleIcon,
  delete: TrashIcon,
  discardDraft: CloseIcon,
  initial: AddCircleIcon,
  editDraft: EditIcon,
  editLive: EditIcon,
  publish: PublishIcon,
  unpublish: UnpublishIcon
};
function formatTimelineEventLabel(type) {
  return TIMELINE_LABELS[type];
}
function getTimelineEventIconComponent(type) {
  return TIMELINE_ICON_COMPONENTS[type];
}
function UserAvatarStack(_ref28) {
  let {
    maxLength,
    userIds
  } = _ref28;
  return /* @__PURE__ */jsx(AvatarStack, {
    maxLength,
    children: userIds.map(userId => /* @__PURE__ */jsx(UserAvatar, {
      user: userId,
      withTooltip: true
    }, userId))
  });
}
const IconWrapper = styled(Flex)(_ref29 => {
  let {
    theme
  } = _ref29;
  var _a;
  const borderColor = (_a = theme.sanity.color.base.skeleton) == null ? void 0 : _a.from;
  return css(_templateObject24 || (_templateObject24 = _taggedTemplateLiteral(["\n    --timeline-hairline-width: 1px;\n    position: relative;\n    z-index: 2;\n    margin: 0;\n    padding: 0;\n\n    &::before {\n      position: absolute;\n      content: '';\n      height: 100%;\n      width: var(--timeline-hairline-width);\n      background: ", ";\n      top: 0;\n      left: calc((100% - var(--timeline-hairline-width)) / 2);\n      z-index: 1;\n    }\n  "])), borderColor);
});
const Root$2 = styled(Button)(_ref30 => {
  let {
    $selected
  } = _ref30;
  return css(_templateObject25 || (_templateObject25 = _taggedTemplateLiteral(["\n    position: relative;\n    width: 100%;\n\n    /* Line styling */\n    &[data-first] ", "::before {\n      height: 50%;\n      top: unset;\n      bottom: 0;\n    }\n\n    &[data-last] ", "::before {\n      height: 50%;\n    }\n\n    ", "\n  "])), IconWrapper, IconWrapper, $selected && css(_templateObject26 || (_templateObject26 = _taggedTemplateLiteral(["\n      ", "::before {\n        background: transparent;\n      }\n    "])), IconWrapper));
});
const IconBox = styled(Box)(_templateObject27 || (_templateObject27 = _taggedTemplateLiteral(["\n  background: var(--card-bg-color);\n  border-radius: 50px;\n  position: relative;\n  z-index: 2;\n"])));
const EventLabel = styled(Text)(_templateObject28 || (_templateObject28 = _taggedTemplateLiteral(["\n  text-transform: capitalize;\n"])));
const TimestampBox = styled(Box)(_templateObject29 || (_templateObject29 = _taggedTemplateLiteral(["\n  min-width: 1rem;\n  margin-left: ", ";\n"])), _ref31 => {
  let {
    theme
  } = _ref31;
  return "-".concat(rem(theme.sanity.space[1]));
});
const TIMELINE_ITEM_EVENT_TONE = {
  initial: "primary",
  create: "primary",
  publish: "positive",
  editLive: "caution",
  editDraft: "caution",
  unpublish: "critical",
  discardDraft: "critical",
  delete: "critical",
  withinSelection: "primary"
};
function TimelineItem(_ref32) {
  let {
    chunk,
    isFirst,
    isLast,
    isLatest,
    isSelected,
    onSelect,
    timestamp,
    type
  } = _ref32;
  const iconComponent = getTimelineEventIconComponent(type);
  const authorUserIds = Array.from(chunk.authors);
  const formattedTimestamp = useMemo(() => {
    const parsedDate = new Date(timestamp);
    const formattedDate = format(parsedDate, "MMM d, yyyy, hh:mm a");
    return formattedDate;
  }, [timestamp]);
  const handleClick = useCallback(evt => {
    evt.preventDefault();
    evt.stopPropagation();
    onSelect(chunk);
  }, [onSelect, chunk]);
  return /* @__PURE__ */jsx(Root$2, {
    $selected: isSelected,
    "data-chunk-id": chunk.id,
    "data-first": isFirst ? true : void 0,
    "data-last": isLast ? true : void 0,
    "data-ui": "timelineItem",
    mode: isSelected ? "default" : "bleed",
    onClick: handleClick,
    padding: 0,
    radius: 2,
    tone: isSelected ? "primary" : TIMELINE_ITEM_EVENT_TONE[chunk.type],
    children: /* @__PURE__ */jsx(Box, {
      paddingX: 2,
      children: /* @__PURE__ */jsxs(Flex, {
        align: "stretch",
        children: [/* @__PURE__ */jsx(IconWrapper, {
          align: "center",
          children: /* @__PURE__ */jsx(IconBox, {
            padding: 2,
            children: /* @__PURE__ */jsx(Text, {
              size: 2,
              children: iconComponent && createElement(iconComponent)
            })
          })
        }), /* @__PURE__ */jsxs(Stack, {
          space: 2,
          margin: 2,
          children: [isLatest && /* @__PURE__ */jsx(Flex, {
            children: /* @__PURE__ */jsx(Card, {
              padding: 1,
              radius: 2,
              shadow: 1,
              tone: isSelected ? "primary" : TIMELINE_ITEM_EVENT_TONE[chunk.type],
              children: /* @__PURE__ */jsx(Label, {
                muted: true,
                size: 0,
                children: "Latest"
              })
            })
          }), /* @__PURE__ */jsx(Box, {
            children: /* @__PURE__ */jsx(EventLabel, {
              size: 1,
              weight: "medium",
              children: formatTimelineEventLabel(type) || /* @__PURE__ */jsx("code", {
                children: type
              })
            })
          }), /* @__PURE__ */jsx(TimestampBox, {
            paddingX: 1,
            children: /* @__PURE__ */jsx(Text, {
              size: 0,
              muted: true,
              children: formattedTimestamp
            })
          })]
        }), /* @__PURE__ */jsx(Flex, {
          flex: 1,
          justify: "flex-end",
          align: "center",
          children: /* @__PURE__ */jsx(UserAvatarStack, {
            maxLength: 3,
            userIds: authorUserIds
          })
        })]
      })
    })
  });
}
const StackWrapper = styled(Stack)(_templateObject30 || (_templateObject30 = _taggedTemplateLiteral(["\n  max-width: 200px;\n"])));
const ListWrapper = styled(Flex)(_templateObject31 || (_templateObject31 = _taggedTemplateLiteral(["\n  max-height: calc(100vh - 198px);\n  min-width: 244px;\n"])));
const Root$1 = styled(Box)(_ref33 => {
  let {
    $visible
  } = _ref33;
  return css(_templateObject32 || (_templateObject32 = _taggedTemplateLiteral(["\n    opacity: 0;\n    pointer-events: none;\n\n    ", "\n  "])), $visible && css(_templateObject33 || (_templateObject33 = _taggedTemplateLiteral(["\n      opacity: 1;\n      pointer-events: auto;\n    "]))));
});
const Timeline = _ref34 => {
  let {
    chunks,
    disabledBeforeFirstChunk,
    hasMoreChunks,
    lastChunk,
    onLoadMore,
    onSelect,
    firstChunk
  } = _ref34;
  const [mounted, setMounted] = useState(false);
  const filteredChunks = useMemo(() => {
    return chunks.filter(c => {
      if (disabledBeforeFirstChunk && firstChunk) {
        return c.index < firstChunk.index;
      }
      return true;
    });
  }, [chunks, disabledBeforeFirstChunk, firstChunk]);
  const selectedIndex = useMemo(() => (lastChunk == null ? void 0 : lastChunk.id) ? filteredChunks.findIndex(c => c.id === lastChunk.id) : -1, [lastChunk == null ? void 0 : lastChunk.id, filteredChunks]);
  const renderItem = useCallback((chunk, _ref35) => {
    let {
      activeIndex
    } = _ref35;
    const isFirst = activeIndex === 0;
    const isLast = filteredChunks && activeIndex === filteredChunks.length - 1 || false;
    return /* @__PURE__ */jsxs(Box, {
      paddingBottom: isLast ? 1 : 0,
      paddingTop: isFirst ? 1 : 0,
      paddingX: 1,
      children: [/* @__PURE__ */jsx(TimelineItem, {
        chunk,
        isFirst,
        isLast,
        isLatest: activeIndex === 0 && !disabledBeforeFirstChunk,
        isSelected: activeIndex === selectedIndex,
        onSelect,
        timestamp: chunk.endTimestamp,
        type: chunk.type
      }), activeIndex === filteredChunks.length - 1 && hasMoreChunks && /* @__PURE__ */jsx(Flex, {
        align: "center",
        justify: "center",
        padding: 4,
        children: /* @__PURE__ */jsx(Spinner, {
          muted: true
        })
      })]
    });
  }, [disabledBeforeFirstChunk, filteredChunks, hasMoreChunks, onSelect, selectedIndex]);
  useEffect(() => setMounted(true), []);
  return /* @__PURE__ */jsxs(Root$1, {
    $visible: !selectedIndex || mounted,
    "data-ui": "timeline",
    children: [filteredChunks.length === 0 && /* @__PURE__ */jsxs(StackWrapper, {
      padding: 3,
      space: 3,
      children: [/* @__PURE__ */jsx(Text, {
        size: 1,
        weight: "semibold",
        children: "No document history"
      }), /* @__PURE__ */jsx(Text, {
        muted: true,
        size: 1,
        children: "When changing the content of the document, the document versions will appear in this menu."
      })]
    }), filteredChunks.length > 0 && /* @__PURE__ */jsx(ListWrapper, {
      direction: "column",
      children: /* @__PURE__ */jsx(CommandList, {
        activeItemDataAttr: "data-hovered",
        ariaLabel: "Document revisions",
        autoFocus: "list",
        initialIndex: selectedIndex,
        initialScrollAlign: "center",
        itemHeight: 40,
        items: filteredChunks,
        onEndReached: onLoadMore,
        onEndReachedIndexOffset: 20,
        overscan: 5,
        renderItem,
        wrapAround: false
      })
    })]
  });
};
Timeline.displayName = "Timeline";
function TimelineError() {
  return /* @__PURE__ */jsxs(Flex, {
    align: "flex-start",
    gap: 3,
    padding: 4,
    children: [/* @__PURE__ */jsx(TextWithTone, {
      tone: "critical",
      children: /* @__PURE__ */jsx(ErrorOutlineIcon, {})
    }), /* @__PURE__ */jsxs(Stack, {
      space: 4,
      children: [/* @__PURE__ */jsx(TextWithTone, {
        size: 1,
        tone: "critical",
        weight: "semibold",
        children: "An error occurred whilst retrieving document changes."
      }), /* @__PURE__ */jsx(TextWithTone, {
        size: 1,
        tone: "critical",
        children: "Document history transactions have not been affected."
      })]
    })]
  });
}
const Root = styled(Popover)(_templateObject34 || (_templateObject34 = _taggedTemplateLiteral(["\n  overflow: hidden;\n  overflow: clip;\n"])));
function TimelineMenu(_ref36) {
  let {
    chunk,
    mode,
    placement
  } = _ref36;
  const {
    setTimelineRange,
    setTimelineMode,
    timelineError,
    ready,
    timelineStore
  } = useDocumentPane();
  const [open, setOpen] = useState(false);
  const [button, setButton] = useState(null);
  const [popover, setPopover] = useState(null);
  const toast = useToast();
  const chunks = useTimelineSelector(timelineStore, state => state.chunks);
  const loading = useTimelineSelector(timelineStore, state => state.isLoading);
  const hasMoreChunks = useTimelineSelector(timelineStore, state => state.hasMoreChunks);
  const realRevChunk = useTimelineSelector(timelineStore, state => state.realRevChunk);
  const sinceTime = useTimelineSelector(timelineStore, state => state.sinceTime);
  const handleOpen = useCallback(() => {
    setTimelineMode(mode);
    setOpen(true);
  }, [mode, setTimelineMode]);
  const handleClose = useCallback(() => {
    setTimelineMode("closed");
    setOpen(false);
  }, [setTimelineMode]);
  const handleClickOutside = useCallback(() => {
    if (open) {
      handleClose();
    }
  }, [handleClose, open]);
  const handleGlobalKeyDown = useCallback(event => {
    if (open && (event.key === "Escape" || event.key === "Tab")) {
      handleClose();
      button == null ? void 0 : button.focus();
    }
  }, [button, handleClose, open]);
  useClickOutside(handleClickOutside, [button, popover]);
  useGlobalKeyDown(handleGlobalKeyDown);
  const selectRev = useCallback(revChunk => {
    try {
      const [sinceId, revId] = timelineStore.findRangeForRev(revChunk);
      setTimelineMode("closed");
      setTimelineRange(sinceId, revId);
    } catch (err) {
      toast.push({
        closable: true,
        description: err.message,
        status: "error",
        title: "Unable to load revision"
      });
    }
  }, [setTimelineMode, setTimelineRange, timelineStore, toast]);
  const selectSince = useCallback(sinceChunk => {
    try {
      const [sinceId, revId] = timelineStore.findRangeForSince(sinceChunk);
      setTimelineMode("closed");
      setTimelineRange(sinceId, revId);
    } catch (err) {
      toast.push({
        closable: true,
        description: err.message,
        status: "error",
        title: "Unable to load revision"
      });
    }
  }, [setTimelineMode, setTimelineRange, timelineStore, toast]);
  const handleLoadMore = useCallback(() => {
    if (!loading) {
      timelineStore.loadMore();
    }
  }, [loading, timelineStore]);
  const content = timelineError ? /* @__PURE__ */jsx(TimelineError, {}) : /* @__PURE__ */jsxs(Fragment, {
    children: [mode === "rev" && /* @__PURE__ */jsx(Timeline, {
      chunks,
      firstChunk: realRevChunk,
      hasMoreChunks,
      lastChunk: realRevChunk,
      onLoadMore: handleLoadMore,
      onSelect: selectRev
    }), mode === "since" && /* @__PURE__ */jsx(Timeline, {
      chunks,
      disabledBeforeFirstChunk: true,
      firstChunk: realRevChunk,
      hasMoreChunks,
      lastChunk: sinceTime,
      onLoadMore: handleLoadMore,
      onSelect: selectSince
    })]
  });
  const timeLabel = useFormattedTimestamp((chunk == null ? void 0 : chunk.endTimestamp) || "");
  const revLabel = chunk ? "".concat(upperFirst(formatTimelineEventLabel(chunk.type)), ": ").concat(timeLabel) : "Latest version";
  const sinceLabel = chunk ? "Since: ".concat(timeLabel) : "Since: unknown version";
  const buttonLabel = mode === "rev" ? revLabel : sinceLabel;
  return /* @__PURE__ */jsx(Root, {
    constrainSize: true,
    content: open && content,
    "data-ui": "versionMenu",
    open,
    placement,
    portal: true,
    ref: setPopover,
    children: /* @__PURE__ */jsx(Button, {
      disabled: !ready,
      mode: "bleed",
      fontSize: 1,
      padding: 2,
      iconRight: SelectIcon,
      onClick: open ? handleClose : handleOpen,
      ref: setButton,
      selected: open,
      style: {
        maxWidth: "100%"
      },
      text: ready ? buttonLabel : "Loading history"
    })
  });
}
function useFormattedTimestamp(time) {
  const formatted = useMemo(() => {
    const parsedDate = time ? new Date(time) : /* @__PURE__ */new Date();
    const formattedDate = format(parsedDate, "MMM d, yyyy, hh:mm a");
    return formattedDate;
  }, [time]);
  return formatted;
}
function LoadingContent() {
  return /* @__PURE__ */jsx(Delay, {
    ms: 300,
    children: /* @__PURE__ */jsxs(Flex, {
      align: "center",
      direction: "column",
      height: "fill",
      justify: "center",
      paddingTop: 3,
      children: [/* @__PURE__ */jsx(Spinner, {
        muted: true
      }), /* @__PURE__ */jsx(Box, {
        marginTop: 3,
        children: /* @__PURE__ */jsx(Text, {
          align: "center",
          muted: true,
          size: 1,
          children: "Loading changes"
        })
      })]
    })
  });
}
function collectLatestAuthorAnnotations(diff) {
  const authorMap = /* @__PURE__ */new Map();
  visitDiff(diff, child => {
    if (child.action === "unchanged" || !("annotation" in child) || !child.annotation) {
      return true;
    }
    const {
      author,
      timestamp
    } = child.annotation;
    const previous = authorMap.get(author);
    if (!previous || previous.timestamp < timestamp) {
      authorMap.set(author, child.annotation);
    }
    return true;
  });
  return Array.from(authorMap.values()).sort((a, b) => a.timestamp < b.timestamp ? 1 : -1);
}
const Scroller = styled(ScrollContainer)(_templateObject35 || (_templateObject35 = _taggedTemplateLiteral(["\n  height: 100%;\n  overflow: auto;\n  position: relative;\n  scroll-behavior: smooth;\n"])));
function ChangesInspector(props) {
  const {
    onClose
  } = props;
  const {
    documentId,
    schemaType,
    timelineError,
    timelineStore,
    value
  } = useDocumentPane();
  const scrollRef = useRef(null);
  const diff = useTimelineSelector(timelineStore, state => state.diff);
  const onOlderRevision = useTimelineSelector(timelineStore, state => state.onOlderRevision);
  const selectionState = useTimelineSelector(timelineStore, state => state.selectionState);
  const sinceTime = useTimelineSelector(timelineStore, state => state.sinceTime);
  const loading = selectionState === "loading";
  const isComparingCurrent = !onOlderRevision;
  const documentContext = React.useMemo(() => ({
    documentId,
    schemaType,
    FieldWrapper: ChangeFieldWrapper,
    rootDiff: diff,
    isComparingCurrent,
    value
  }), [documentId, diff, isComparingCurrent, schemaType, value]);
  const changeAnnotations = React.useMemo(() => diff ? collectLatestAuthorAnnotations(diff) : [], [diff]);
  return /* @__PURE__ */jsxs(Flex, {
    "data-testid": "review-changes-pane",
    direction: "column",
    height: "fill",
    overflow: "hidden",
    children: [/* @__PURE__ */jsx(DocumentInspectorHeader, {
      as: "header",
      closeButtonLabel: "Close review changes",
      flex: "none",
      onClose,
      title: "Review changes",
      children: /* @__PURE__ */jsxs(Flex, {
        gap: 1,
        padding: 3,
        paddingTop: 0,
        paddingBottom: 2,
        children: [/* @__PURE__ */jsx(Box, {
          flex: 1,
          children: /* @__PURE__ */jsx(TimelineMenu, {
            mode: "since",
            chunk: sinceTime,
            placement: "bottom-start"
          })
        }), /* @__PURE__ */jsx(Box, {
          flex: "none",
          children: /* @__PURE__ */jsx(DiffTooltip, {
            annotations: changeAnnotations,
            description: "Changes by",
            portal: true,
            children: /* @__PURE__ */jsx(AvatarStack, {
              maxLength: 4,
              children: changeAnnotations.map(_ref37 => {
                let {
                  author
                } = _ref37;
                return /* @__PURE__ */jsx(UserAvatar, {
                  user: author
                }, author);
              })
            })
          })
        })]
      })
    }), /* @__PURE__ */jsx(Card, {
      flex: 1,
      children: /* @__PURE__ */jsx(BoundaryElementProvider, {
        element: scrollRef.current,
        children: /* @__PURE__ */jsx(Scroller, {
          "data-ui": "Scroller",
          ref: scrollRef,
          children: /* @__PURE__ */jsx(Box, {
            flex: 1,
            padding: 4,
            children: /* @__PURE__ */jsx(Content, {
              diff,
              documentContext,
              error: timelineError,
              loading,
              schemaType
            })
          })
        })
      })
    })]
  });
}
function Content(_ref38) {
  let {
    error,
    diff,
    documentContext,
    loading,
    schemaType
  } = _ref38;
  if (error) {
    return /* @__PURE__ */jsx(NoChanges, {});
  }
  if (loading) {
    return /* @__PURE__ */jsx(LoadingContent, {});
  }
  if (!diff) {
    return /* @__PURE__ */jsx(NoChanges, {});
  }
  return /* @__PURE__ */jsx(DocumentChangeContext.Provider, {
    value: documentContext,
    children: /* @__PURE__ */jsx(ChangeList, {
      diff,
      schemaType
    })
  });
}
const changesInspector = {
  name: HISTORY_INSPECTOR_NAME,
  useMenuItem: () => {
    const {
      features
    } = useDeskTool();
    return {
      hidden: !features.reviewChanges,
      icon: RestoreIcon,
      title: "Review changes"
    };
  },
  component: ChangesInspector,
  onClose: _ref39 => {
    let {
      params
    } = _ref39;
    return {
      params: {
        ...params,
        since: void 0
      }
    };
  },
  onOpen: _ref40 => {
    let {
      params
    } = _ref40;
    return {
      params: {
        ...params,
        since: "@lastPublished"
      }
    };
  }
};
const documentActions = [PublishAction, UnpublishAction, DiscardChangesAction, DuplicateAction, DeleteAction, HistoryRestoreAction];
const documentBadges = [LiveEditBadge];
const deskTool = definePlugin(options => ({
  name: "@sanity/desk-tool",
  document: {
    actions: prevActions => {
      const actions = prevActions.slice(0);
      for (const action of documentActions) {
        if (!actions.includes(action)) actions.push(action);
      }
      return actions;
    },
    badges: prevBadges => {
      const badges = prevBadges.slice(0);
      for (const badge of documentBadges) {
        if (!badges.includes(badge)) badges.push(badge);
      }
      return badges;
    },
    inspectors: [validationInspector, changesInspector]
  },
  tools: [{
    name: (options == null ? void 0 : options.name) || "desk",
    title: (options == null ? void 0 : options.title) || "Desk",
    icon: (options == null ? void 0 : options.icon) || MasterDetailIcon,
    component: lazy(() => import('./index-0de920bc.js').then(function (n) {
      return n.index;
    })),
    canHandleIntent: (intent, params) => {
      return Boolean(intent === "edit" && params.id || intent === "create" && params.type || intent === "create" && params.template);
    },
    getIntentState,
    options,
    router
  }]
}));
function getInspectorItems(_ref41) {
  let {
    currentInspector,
    hasValue,
    inspectors,
    inspectorMenuItems
  } = _ref41;
  return inspectors.map((inspector, index) => {
    var _a;
    const menuItem = inspectorMenuItems[index];
    if (!menuItem || menuItem.hidden) return null;
    return {
      action: "".concat(INSPECT_ACTION_PREFIX).concat(inspector.name),
      group: menuItem.showAsAction ? void 0 : "inspectors",
      icon: menuItem.icon,
      isDisabled: !hasValue,
      selected: (currentInspector == null ? void 0 : currentInspector.name) === inspector.name,
      shortcut: (_a = menuItem.hotkeys) == null ? void 0 : _a.join("+"),
      showAsAction: menuItem.showAsAction,
      title: menuItem.title,
      tone: menuItem.tone
    };
  }).filter(Boolean);
}
function getInspectItem(_ref42) {
  let {
    hasValue
  } = _ref42;
  return {
    action: "inspect",
    group: "inspectors",
    title: "Inspect",
    icon: BinaryDocumentIcon,
    isDisabled: !hasValue,
    shortcut: "Ctrl+Alt+I"
  };
}
function getProductionPreviewItem(_ref43) {
  let {
    previewUrl
  } = _ref43;
  if (!previewUrl) return null;
  return {
    action: "production-preview",
    group: "links",
    title: "Open preview",
    icon: EarthAmericasIcon,
    shortcut: "Ctrl+Alt+O"
  };
}
function getMenuItems(params) {
  const inspectorItems = getInspectorItems(params);
  const items = [
  // Get production preview item
  getProductionPreviewItem(params)].filter(Boolean);
  return [...inspectorItems,
  // TODO: convert to inspector or document view?
  getInspectItem(params), ...items];
}
const isSanityDocument = value => isRecord(value) && typeof value._id === "string" && typeof value._type === "string";
function usePreviewUrl(value) {
  const [previewUrl, setPreviewUrl] = useState(void 0);
  const [error, setError] = useState(null);
  const {
    resolveProductionUrl
  } = useSource().document;
  const value$ = useAsObservable(value);
  if (error) throw error;
  useEffect(() => {
    value$.pipe(
    // this so that the preview URL isn't fetched on every keystroke
    debounceTime(500), switchMap(document => isSanityDocument(document) ? from(resolveProductionUrl({
      document
    })) : of(void 0)), catchError(e => {
      const message = isRecord(e) && typeof e.message === "string" ? e.message : "Unknown error";
      throw new Error("An error was thrown while trying to get your preview url: ".concat(message));
    })).subscribe({
      next: setPreviewUrl,
      error: setError
    });
  }, [resolveProductionUrl, value$]);
  return previewUrl;
}
function getInitialValueTemplateOpts(templates, opts) {
  const payload = opts.panePayload || {};
  const structureNodeTemplate = opts.templateName;
  if (opts.urlTemplate && structureNodeTemplate && structureNodeTemplate !== opts.urlTemplate) {
    console.warn("Conflicting templates: URL says \"".concat(opts.urlTemplate, "\", structure node says \"").concat(structureNodeTemplate, "\". Using \"").concat(structureNodeTemplate, "\"."));
  }
  const template = structureNodeTemplate || opts.urlTemplate;
  const typeTemplates = templates.filter(t => t.schemaType === opts.documentType);
  const templateParams = {
    ...opts.templateParams,
    ...(typeof payload === "object" ? payload || {} : {})
  };
  let templateName = template;
  if (!template && typeTemplates.length === 1) {
    templateName = typeTemplates[0].id;
  }
  return {
    templateName,
    templateParams
  };
}
const InspectorMenuItem = memo(function InspectorMenuItem2(props) {
  const {
    documentId,
    documentType,
    index,
    setMenuItem,
    useMenuItem
  } = props;
  const node = useUnique(useMenuItem({
    documentId,
    documentType
  }));
  useEffect(() => {
    setMenuItem(index, node);
  }, [index, node, setMenuItem]);
  return /* @__PURE__ */jsx(Fragment, {});
});
function DocumentInspectorMenuItemsResolver(props) {
  const {
    documentId,
    documentType,
    inspectors,
    onMenuItems
  } = props;
  const len = inspectors.length;
  const lenRef = useRef(len);
  const [menuItems, setMenuItems] = useState(() => Array.from(new Array(len)));
  const menuItemsRef = useRef(menuItems);
  useEffect(() => {
    if (lenRef.current !== len) {
      const newFieldActions = Array.from(new Array(len));
      for (let i = 0; i < len; i++) {
        newFieldActions[i] = menuItemsRef.current[i];
      }
      lenRef.current = len;
      setMenuItems(() => {
        menuItemsRef.current = newFieldActions;
        return newFieldActions;
      });
    }
  }, [len]);
  const setMenuItem = useCallback((index, node) => {
    setMenuItems(prev => {
      const next = [...prev];
      next[index] = node;
      menuItemsRef.current = next;
      return next;
    });
  }, []);
  useEffect(() => {
    onMenuItems(menuItems.filter(Boolean));
  }, [menuItems, onMenuItems]);
  return /* @__PURE__ */jsx(Fragment, {
    children: inspectors.map((inspector, inspectorIndex) => inspector.useMenuItem && /* @__PURE__ */jsx(InspectorMenuItem, {
      documentId,
      documentType,
      index: inspectorIndex,
      setMenuItem,
      useMenuItem: inspector.useMenuItem
    }, inspector.name))
  });
}
const DocumentPaneProvider = memo(props => {
  const {
    children,
    index,
    pane,
    paneKey
  } = props;
  const schema = useSchema();
  const templates = useTemplates();
  const {
    actions: documentActions,
    badges: documentBadges,
    unstable_fieldActions: fieldActionsResolver,
    unstable_languageFilter: languageFilterResolver,
    inspectors: inspectorsResolver
  } = useSource().document;
  const presenceStore = usePresenceStore();
  const paneRouter = usePaneRouter();
  const setPaneParams = paneRouter.setParams;
  const {
    features
  } = useDeskTool();
  const {
    push: pushToast
  } = useToast();
  const {
    options,
    menuItemGroups = DEFAULT_MENU_ITEM_GROUPS,
    title = null,
    views: viewsProp = []
  } = pane;
  const paneOptions = useUnique(options);
  const documentIdRaw = paneOptions.id;
  const documentId = getPublishedId(documentIdRaw);
  const documentType = options.type;
  const params = useUnique(paneRouter.params) || EMPTY_PARAMS;
  const panePayload = useUnique(paneRouter.payload);
  const {
    templateName,
    templateParams
  } = useMemo(() => getInitialValueTemplateOpts(templates, {
    documentType,
    templateName: paneOptions.template,
    templateParams: paneOptions.templateParameters,
    panePayload,
    urlTemplate: params.template
  }), [documentType, paneOptions, params, panePayload, templates]);
  const initialValueRaw = useInitialValue({
    documentId,
    documentType,
    templateName,
    templateParams
  });
  const initialValue = useUnique(initialValueRaw);
  const {
    patch
  } = useDocumentOperation(documentId, documentType);
  const editState = useEditState(documentId, documentType);
  const {
    validation: validationRaw
  } = useValidationStatus(documentId, documentType);
  const connectionState = useConnectionState(documentId, documentType);
  const schemaType = schema.get(documentType);
  const value = (editState == null ? void 0 : editState.draft) || (editState == null ? void 0 : editState.published) || initialValue.value;
  const [inspectorMenuItems, setInspectorMenuItems] = useState([]);
  const actions = useMemo(() => documentActions({
    schemaType: documentType,
    documentId
  }), [documentActions, documentId, documentType]);
  const badges = useMemo(() => documentBadges({
    schemaType: documentType,
    documentId
  }), [documentBadges, documentId, documentType]);
  const languageFilter = useMemo(() => languageFilterResolver({
    schemaType: documentType,
    documentId
  }), [documentId, documentType, languageFilterResolver]);
  const validation = useUnique(validationRaw);
  const views = useUnique(viewsProp);
  const [focusPath, setFocusPath] = useState(() => params.path ? fromString(params.path) : []);
  const activeViewId = params.view || views[0] && views[0].id || null;
  const [timelineMode, setTimelineMode] = useState("closed");
  const [timelineError, setTimelineError] = useState(null);
  const timelineStore = useTimelineStore({
    documentId,
    documentType,
    onError: setTimelineError,
    rev: params.rev,
    since: params.since
  });
  const onOlderRevision = useTimelineSelector(timelineStore, state => state.onOlderRevision);
  const revTime = useTimelineSelector(timelineStore, state => state.revTime);
  const sinceAttributes = useTimelineSelector(timelineStore, state => state.sinceAttributes);
  const timelineDisplayed = useTimelineSelector(timelineStore, state => state.timelineDisplayed);
  const timelineReady = useTimelineSelector(timelineStore, state => state.timelineReady);
  const previewUrl = usePreviewUrl(value);
  const [presence, setPresence] = useState([]);
  useEffect(() => {
    const subscription = presenceStore.documentPresence(documentId).subscribe(nextPresence => {
      setPresence(nextPresence);
    });
    return () => {
      subscription.unsubscribe();
    };
  }, [documentId, presenceStore]);
  const inspectors = useMemo(() => inspectorsResolver({
    documentId,
    documentType
  }), [documentId, documentType, inspectorsResolver]);
  const [inspectorName, setInspectorName] = useState(() => params.inspect || null);
  const inspectParamRef = useRef(params.inspect);
  useEffect(() => {
    if (inspectParamRef.current !== params.inspect) {
      inspectParamRef.current = params.inspect;
      setInspectorName(params.inspect || null);
    }
  }, [params.inspect]);
  const currentInspector = inspectors == null ? void 0 : inspectors.find(i => i.name === inspectorName);
  const resolvedChangesInspector = inspectors.find(i => i.name === HISTORY_INSPECTOR_NAME);
  const changesOpen = (currentInspector == null ? void 0 : currentInspector.name) === HISTORY_INSPECTOR_NAME;
  const hasValue = Boolean(value);
  const menuItems = useMemo(() => getMenuItems({
    currentInspector,
    features,
    hasValue,
    inspectorMenuItems,
    inspectors,
    previewUrl
  }), [currentInspector, features, hasValue, inspectorMenuItems, inspectors, previewUrl]);
  const inspectOpen = params.inspect === "on";
  const compareValue = changesOpen ? sinceAttributes : (editState == null ? void 0 : editState.published) || null;
  const fieldActions = useMemo(() => schemaType ? fieldActionsResolver({
    documentId,
    documentType,
    schemaType
  }) : [], [documentId, documentType, fieldActionsResolver, schemaType]);
  const ready = connectionState === "connected" && editState.ready && (timelineReady || !!timelineError);
  const displayed = useMemo(() => onOlderRevision ? timelineDisplayed || {
    _id: value._id,
    _type: value._type
  } : value, [onOlderRevision, timelineDisplayed, value]);
  const setTimelineRange = useCallback((newSince, newRev) => {
    setPaneParams({
      ...params,
      since: newSince,
      rev: newRev || void 0
    });
  }, [params, setPaneParams]);
  const handleFocus = useCallback(nextFocusPath => {
    setFocusPath(nextFocusPath);
    presenceStore.setLocation([{
      type: "document",
      documentId,
      path: nextFocusPath,
      lastActiveAt: /* @__PURE__ */new Date().toISOString()
    }]);
  }, [documentId, presenceStore, setFocusPath]);
  const handleBlur = useCallback(blurredPath => {
    setFocusPath([]);
  }, [setFocusPath]);
  const patchRef = useRef(() => {
    throw new Error("Nope");
  });
  patchRef.current = event => {
    patch.execute(toMutationPatches(event.patches), initialValue.value);
  };
  const handleChange = useCallback(event => patchRef.current(event), []);
  const closeInspector = useCallback(closeInspectorName => {
    var _a, _b, _c, _d;
    const inspector = closeInspectorName && inspectors.find(i => i.name === closeInspectorName);
    if (closeInspectorName && !inspector) {
      console.warn("No inspector named \"".concat(closeInspectorName, "\""));
      return;
    }
    if (!currentInspector) {
      return;
    }
    if (inspector) {
      const result = (_b = (_a = inspector.onClose) == null ? void 0 : _a.call(inspector, {
        params
      })) != null ? _b : {
        params
      };
      setInspectorName(null);
      inspectParamRef.current = void 0;
      setPaneParams({
        ...result.params,
        inspect: void 0
      });
      return;
    }
    if (currentInspector) {
      const result = (_d = (_c = currentInspector.onClose) == null ? void 0 : _c.call(currentInspector, {
        params
      })) != null ? _d : {
        params
      };
      setInspectorName(null);
      inspectParamRef.current = void 0;
      setPaneParams({
        ...result.params,
        inspect: void 0
      });
    }
  }, [currentInspector, inspectors, params, setPaneParams]);
  const openInspector = useCallback((nextInspectorName, paneParams) => {
    var _a, _b, _c, _d;
    const nextInspector = inspectors.find(i => i.name === nextInspectorName);
    if (!nextInspector) {
      console.warn("No inspector named \"".concat(nextInspectorName, "\""));
      return;
    }
    if ((currentInspector == null ? void 0 : currentInspector.name) === nextInspector.name) {
      setPaneParams({
        ...params,
        ...paneParams,
        inspect: nextInspector.name
      });
      return;
    }
    let currentParams = params;
    if (currentInspector) {
      const closeResult = (_b = (_a = nextInspector.onClose) == null ? void 0 : _a.call(nextInspector, {
        params: currentParams
      })) != null ? _b : {
        params: currentParams
      };
      currentParams = closeResult.params;
    }
    const result = (_d = (_c = nextInspector.onOpen) == null ? void 0 : _c.call(nextInspector, {
      params: currentParams
    })) != null ? _d : {
      params: currentParams
    };
    setInspectorName(nextInspector.name);
    inspectParamRef.current = nextInspector.name;
    setPaneParams({
      ...result.params,
      ...paneParams,
      inspect: nextInspector.name
    });
  }, [currentInspector, inspectors, params, setPaneParams]);
  const handleHistoryClose = useCallback(() => {
    if (resolvedChangesInspector) {
      closeInspector(resolvedChangesInspector.name);
    }
  }, [closeInspector, resolvedChangesInspector]);
  const handleHistoryOpen = useCallback(() => {
    if (!features.reviewChanges) {
      return;
    }
    if (resolvedChangesInspector) {
      openInspector(resolvedChangesInspector.name);
    }
  }, [features.reviewChanges, openInspector, resolvedChangesInspector]);
  const handlePaneClose = useCallback(() => paneRouter.closeCurrent(), [paneRouter]);
  const handlePaneSplit = useCallback(() => paneRouter.duplicateCurrent(), [paneRouter]);
  const toggleLegacyInspect = useCallback(function () {
    let toggle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !inspectOpen;
    if (toggle) {
      setPaneParams({
        ...params,
        inspect: "on"
      });
    } else {
      setPaneParams(omit(params, "inspect"));
    }
  }, [inspectOpen, params, setPaneParams]);
  const handleMenuAction = useCallback(item => {
    if (item.action === "production-preview" && previewUrl) {
      window.open(previewUrl);
      return true;
    }
    if (item.action === "inspect") {
      toggleLegacyInspect(true);
      return true;
    }
    if (item.action === "reviewChanges") {
      handleHistoryOpen();
      return true;
    }
    if (typeof item.action === "string" && item.action.startsWith(INSPECT_ACTION_PREFIX)) {
      const nextInspectorName = item.action.slice(INSPECT_ACTION_PREFIX.length);
      const nextInspector = inspectors.find(i => i.name === nextInspectorName);
      if (nextInspector) {
        if (nextInspector.name === inspectorName) {
          closeInspector(nextInspector.name);
        } else {
          openInspector(nextInspector.name);
        }
        return true;
      }
    }
    return false;
  }, [closeInspector, handleHistoryOpen, inspectorName, inspectors, openInspector, previewUrl, toggleLegacyInspect]);
  const handleKeyUp = useCallback(event => {
    for (const item of menuItems) {
      if (item.shortcut) {
        if (isHotkey(item.shortcut, event)) {
          event.preventDefault();
          event.stopPropagation();
          handleMenuAction(item);
          return;
        }
      }
    }
  }, [handleMenuAction, menuItems]);
  const handleLegacyInspectClose = useCallback(() => toggleLegacyInspect(false), [toggleLegacyInspect]);
  const [openPath, onSetOpenPath] = useState([]);
  const [fieldGroupState, onSetFieldGroupState] = useState();
  const [collapsedPaths, onSetCollapsedPath] = useState();
  const [collapsedFieldSets, onSetCollapsedFieldSets] = useState();
  const handleOnSetCollapsedPath = useCallback((path, collapsed) => {
    onSetCollapsedPath(prevState => setAtPath(prevState, path, collapsed));
  }, []);
  const handleOnSetCollapsedFieldSet = useCallback((path, collapsed) => {
    onSetCollapsedFieldSets(prevState => setAtPath(prevState, path, collapsed));
  }, []);
  const handleSetActiveFieldGroup = useCallback((path, groupName) => onSetFieldGroupState(prevState => setAtPath(prevState, path, groupName)), []);
  const requiredPermission = value._createdAt ? "update" : "create";
  const liveEdit = Boolean(schemaType == null ? void 0 : schemaType.liveEdit);
  const docId = value._id ? value._id : "dummy-id";
  const docPermissionsInput = useMemo(() => {
    return {
      ...value,
      _id: liveEdit ? getPublishedId(docId) : getDraftId(docId)
    };
  }, [liveEdit, value, docId]);
  const [permissions, isPermissionsLoading] = useDocumentValuePermissions({
    document: docPermissionsInput,
    permission: requiredPermission
  });
  const isNonExistent = !(value == null ? void 0 : value._id);
  const readOnly = useMemo(() => {
    var _a;
    const hasNoPermission = !isPermissionsLoading && !(permissions == null ? void 0 : permissions.granted);
    const updateActionDisabled = !isActionEnabled(schemaType, "update");
    const createActionDisabled = isNonExistent && !isActionEnabled(schemaType, "create");
    const reconnecting = connectionState === "reconnecting";
    const isLocked = (_a = editState.transactionSyncLock) == null ? void 0 : _a.enabled;
    return !ready || revTime !== null || hasNoPermission || updateActionDisabled || createActionDisabled || reconnecting || isLocked;
  }, [connectionState, isNonExistent, isPermissionsLoading, permissions == null ? void 0 : permissions.granted, ready, revTime, schemaType, editState.transactionSyncLock]);
  const formState = useFormState(schemaType, {
    value: displayed,
    readOnly,
    comparisonValue: compareValue,
    focusPath,
    openPath,
    collapsedPaths,
    presence,
    validation,
    collapsedFieldSets,
    fieldGroupState,
    changesOpen
  });
  const formStateRef = useRef(formState);
  formStateRef.current = formState;
  const setOpenPath = useCallback(path => {
    const ops = getExpandOperations(formStateRef.current, path);
    ops.forEach(op => {
      if (op.type === "expandPath") {
        onSetCollapsedPath(prevState => setAtPath(prevState, op.path, false));
      }
      if (op.type === "expandFieldSet") {
        onSetCollapsedFieldSets(prevState => setAtPath(prevState, op.path, false));
      }
      if (op.type === "setSelectedGroup") {
        onSetFieldGroupState(prevState => setAtPath(prevState, op.path, op.groupName));
      }
    });
    onSetOpenPath(path);
  }, [formStateRef]);
  const documentPane = {
    actions,
    activeViewId,
    badges,
    changesOpen,
    closeInspector,
    collapsedFieldSets,
    collapsedPaths,
    compareValue,
    connectionState,
    displayed,
    documentId,
    documentIdRaw,
    documentType,
    editState,
    fieldActions,
    focusPath,
    inspector: currentInspector || null,
    inspectors,
    menuItems,
    onBlur: handleBlur,
    onChange: handleChange,
    onFocus: handleFocus,
    onPathOpen: setOpenPath,
    onHistoryClose: handleHistoryClose,
    onHistoryOpen: handleHistoryOpen,
    onInspectClose: handleLegacyInspectClose,
    onKeyUp: handleKeyUp,
    onMenuAction: handleMenuAction,
    onPaneClose: handlePaneClose,
    onPaneSplit: handlePaneSplit,
    onSetActiveFieldGroup: handleSetActiveFieldGroup,
    onSetCollapsedPath: handleOnSetCollapsedPath,
    onSetCollapsedFieldSet: handleOnSetCollapsedFieldSet,
    openInspector,
    index,
    inspectOpen,
    validation,
    menuItemGroups: menuItemGroups || [],
    paneKey,
    previewUrl,
    ready,
    schemaType,
    isPermissionsLoading,
    permissions,
    setTimelineMode,
    setTimelineRange,
    timelineError,
    timelineMode,
    timelineStore,
    title,
    value,
    views,
    formState,
    unstable_languageFilter: languageFilter
  };
  useEffect(() => {
    if (connectionState === "reconnecting") {
      pushToast({
        id: "sanity/desk/reconnecting",
        status: "warning",
        title: /* @__PURE__ */jsx(Fragment, {
          children: "Connection lost. Reconnecting\u2026"
        })
      });
    }
  }, [connectionState, pushToast]);
  useEffect(() => {
    var _a;
    if (ready && params.path) {
      const {
        path,
        ...restParams
      } = params;
      const pathFromUrl = resolveKeyedPath((_a = formStateRef.current) == null ? void 0 : _a.value, fromString(path));
      setFocusPath(pathFromUrl);
      setOpenPath(pathFromUrl);
      paneRouter.setParams(restParams);
    }
  }, [params, documentId, setOpenPath, ready, paneRouter]);
  const [rootFieldActionNodes, setRootFieldActionNodes] = useState([]);
  return /* @__PURE__ */jsxs(DocumentPaneContext.Provider, {
    value: documentPane,
    children: [inspectors.length > 0 && /* @__PURE__ */jsx(DocumentInspectorMenuItemsResolver, {
      documentId,
      documentType,
      inspectors,
      onMenuItems: setInspectorMenuItems
    }), fieldActions.length > 0 && schemaType && /* @__PURE__ */jsx(FieldActionsResolver, {
      actions: fieldActions,
      documentId,
      documentType,
      onActions: setRootFieldActionNodes,
      path: EMPTY_ARRAY$1,
      schemaType
    }), /* @__PURE__ */jsx(FieldActionsProvider, {
      actions: rootFieldActionNodes,
      path: EMPTY_ARRAY$1,
      children
    })]
  });
});
DocumentPaneProvider.displayName = "DocumentPaneProvider";
var __defProp$e = Object.defineProperty;
var __defNormalProp$e = (obj, key, value) => key in obj ? __defProp$e(obj, key, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key] = value;
var __publicField$e = (obj, key, value) => {
  __defNormalProp$e(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class SerializeError extends Error {
  constructor(message, parentPath, pathSegment, hint) {
    super(message);
    __publicField$e(this, "path");
    __publicField$e(this, "helpId");
    const segment = typeof pathSegment === "undefined" ? "<unknown>" : "".concat(pathSegment);
    this.path = (parentPath || []).concat(hint ? "".concat(segment, " (").concat(hint, ")") : segment);
  }
  withHelpUrl(id) {
    this.helpId = id;
    return this;
  }
}
var HELP_URL = /* @__PURE__ */(HELP_URL2 => {
  HELP_URL2["ID_REQUIRED"] = "structure-node-id-required";
  HELP_URL2["TITLE_REQUIRED"] = "structure-title-required";
  HELP_URL2["FILTER_REQUIRED"] = "structure-filter-required";
  HELP_URL2["INVALID_LIST_ITEM"] = "structure-invalid-list-item";
  HELP_URL2["COMPONENT_REQUIRED"] = "structure-view-component-required";
  HELP_URL2["DOCUMENT_ID_REQUIRED"] = "structure-document-id-required";
  HELP_URL2["DOCUMENT_TYPE_REQUIRED"] = "structure-document-type-required";
  HELP_URL2["SCHEMA_TYPE_REQUIRED"] = "structure-schema-type-required";
  HELP_URL2["SCHEMA_TYPE_NOT_FOUND"] = "structure-schema-type-not-found";
  HELP_URL2["LIST_ITEMS_MUST_BE_ARRAY"] = "structure-list-items-must-be-array";
  HELP_URL2["QUERY_PROVIDED_FOR_FILTER"] = "structure-query-provided-for-filter";
  HELP_URL2["ACTION_OR_INTENT_REQUIRED"] = "structure-action-or-intent-required";
  HELP_URL2["LIST_ITEM_IDS_MUST_BE_UNIQUE"] = "structure-list-item-ids-must-be-unique";
  HELP_URL2["ACTION_AND_INTENT_MUTUALLY_EXCLUSIVE"] = "structure-action-and-intent-mutually-exclusive";
  return HELP_URL2;
})(HELP_URL || {});
const IMPLICIT_FIELDS = ["_id", "_type", "_createdAt", "_updatedAt", "_rev"];
function joinReferences(schemaType, path) {
  const [head, ...tail] = path;
  if (!("fields" in schemaType)) {
    return "";
  }
  const schemaField = schemaType.fields.find(field => field.name === head);
  if (!schemaField) {
    if (!IMPLICIT_FIELDS.includes(head)) {
      console.warn('The current ordering config targeted the nonexistent field "%s" on schema type "%s". It should be one of %o', head, schemaType.name, schemaType.fields.map(field => field.name));
    }
    return "";
  }
  if ("to" in schemaField.type && schemaField.type.name === "reference") {
    const refTypes = schemaField.type.to;
    return "".concat(head, "->{").concat(refTypes.map(refType => joinReferences(refType, tail)).join(","), "}");
  }
  const tailFields = tail.length > 0 && joinReferences(schemaField.type, tail);
  const tailWrapper = tailFields ? "{".concat(tailFields, "}") : "";
  return tail.length > 0 ? "".concat(head).concat(tailWrapper) : head;
}
function getExtendedProjection(schemaType, orderBy) {
  return orderBy.map(ordering => joinReferences(schemaType, ordering.field.split("."))).join(", ");
}
const ORDER_BY_UPDATED_AT = {
  title: "Last edited",
  name: "lastEditedDesc",
  by: [{
    field: "_updatedAt",
    direction: "desc"
  }]
};
const ORDER_BY_CREATED_AT = {
  title: "Created",
  name: "lastCreatedDesc",
  by: [{
    field: "_createdAt",
    direction: "desc"
  }]
};
const DEFAULT_SELECTED_ORDERING_OPTION = ORDER_BY_UPDATED_AT;
const DEFAULT_ORDERING_OPTIONS = [ORDER_BY_UPDATED_AT,
// _updatedAt
ORDER_BY_CREATED_AT
// _createdAt
];

var __defProp$d = Object.defineProperty;
var __defNormalProp$d = (obj, key, value) => key in obj ? __defProp$d(obj, key, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key] = value;
var __publicField$d = (obj, key, value) => {
  __defNormalProp$d(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
function maybeSerializeMenuItem(item, index, path) {
  return item instanceof MenuItemBuilder ? item.serialize({
    path,
    index
  }) : item;
}
class MenuItemBuilder {
  constructor(_context, spec) {
    this._context = _context;
    __publicField$d(this, "spec");
    this.spec = spec ? spec : {};
  }
  action(action) {
    return this.clone({
      action
    });
  }
  getAction() {
    return this.spec.action;
  }
  intent(intent) {
    return this.clone({
      intent
    });
  }
  getIntent() {
    return this.spec.intent;
  }
  title(title) {
    return this.clone({
      title
    });
  }
  getTitle() {
    return this.spec.title;
  }
  group(group) {
    return this.clone({
      group
    });
  }
  getGroup() {
    return this.spec.group;
  }
  icon(icon) {
    return this.clone({
      icon
    });
  }
  getIcon() {
    return this.spec.icon;
  }
  params(params) {
    return this.clone({
      params
    });
  }
  getParams() {
    return this.spec.params;
  }
  showAsAction() {
    let showAsAction = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
    return this.clone({
      showAsAction: Boolean(showAsAction)
    });
  }
  getShowAsAction() {
    return this.spec.showAsAction;
  }
  serialize() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      path: []
    };
    const {
      title,
      action,
      intent
    } = this.spec;
    if (!title) {
      const hint = typeof action === "string" ? "action: \"".concat(action, "\"") : void 0;
      throw new SerializeError("`title` is required for menu item", options.path, options.index, hint).withHelpUrl(HELP_URL.TITLE_REQUIRED);
    }
    if (!action && !intent) {
      throw new SerializeError("`action` or `intent` required for menu item with title ".concat(this.spec.title), options.path, options.index, "\"".concat(title, "\"")).withHelpUrl(HELP_URL.ACTION_OR_INTENT_REQUIRED);
    }
    if (intent && action) {
      throw new SerializeError("cannot set both `action` AND `intent`", options.path, options.index, "\"".concat(title, "\"")).withHelpUrl(HELP_URL.ACTION_AND_INTENT_MUTUALLY_EXCLUSIVE);
    }
    return {
      ...this.spec,
      title
    };
  }
  clone(withSpec) {
    const builder = new MenuItemBuilder(this._context);
    builder.spec = {
      ...this.spec,
      ...(withSpec || {})
    };
    return builder;
  }
}
function getOrderingMenuItem(context, ordering, extendedProjection) {
  return new MenuItemBuilder(context).group("sorting").title("Sort by ".concat(ordering.title)).icon(SortIcon).action("setSortOrder").params({
    by: ordering.by,
    extendedProjection
  });
}
function getOrderingMenuItemsForSchemaType(context, typeName) {
  const {
    schema
  } = context;
  const type = typeof typeName === "string" ? schema.get(typeName) : typeName;
  if (!type || !("orderings" in type)) {
    return [];
  }
  return (type.orderings ? type.orderings.concat(DEFAULT_ORDERING_OPTIONS) : DEFAULT_ORDERING_OPTIONS).map(ordering => getOrderingMenuItem(context, ordering, getExtendedProjection(type, ordering.by)));
}
var __defProp$c = Object.defineProperty;
var __defNormalProp$c = (obj, key, value) => key in obj ? __defProp$c(obj, key, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key] = value;
var __publicField$c = (obj, key, value) => {
  __defNormalProp$c(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
function maybeSerializeMenuItemGroup(item, index, path) {
  return item instanceof MenuItemGroupBuilder ? item.serialize({
    path,
    index
  }) : item;
}
class MenuItemGroupBuilder {
  constructor(_context, spec) {
    this._context = _context;
    __publicField$c(this, "_id");
    __publicField$c(this, "_title");
    this._id = spec ? spec.id : "";
    this._title = spec ? spec.title : "";
  }
  id(id) {
    return new MenuItemGroupBuilder(this._context, {
      id,
      title: this._title
    });
  }
  getId() {
    return this._id;
  }
  title(title) {
    return new MenuItemGroupBuilder(this._context, {
      id: this._id,
      title
    });
  }
  getTitle() {
    return this._title;
  }
  serialize() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      path: []
    };
    const {
      _id,
      _title
    } = this;
    if (!_id) {
      throw new SerializeError("`id` is required for a menu item group", options.path, options.index, _title).withHelpUrl(HELP_URL.ID_REQUIRED);
    }
    if (!_title) {
      throw new SerializeError("`title` is required for a menu item group", options.path, _id).withHelpUrl(HELP_URL.TITLE_REQUIRED);
    }
    return {
      id: _id,
      title: _title
    };
  }
}
const disallowedPattern = /([^A-Za-z0-9-_.])/;
function validateId(id, parentPath, pathSegment) {
  if (typeof id !== "string") {
    throw new SerializeError("Structure node id must be of type string, got ".concat(typeof id), parentPath, pathSegment);
  }
  const [disallowedChar] = id.match(disallowedPattern) || [];
  if (disallowedChar) {
    throw new SerializeError("Structure node id cannot contain character \"".concat(disallowedChar, "\""), parentPath, pathSegment);
  }
  if (id.startsWith("__edit__")) {
    throw new SerializeError("Structure node id cannot start with __edit__", parentPath, pathSegment);
  }
  return id;
}
function getStructureNodeId(title, id) {
  if (id) {
    return id;
  }
  const camelCased = camelCase(title);
  return disallowedPattern.test(camelCased) ? camelCase(speakingurl(title)) : camelCased;
}
var __defProp$b = Object.defineProperty;
var __defNormalProp$b = (obj, key, value) => key in obj ? __defProp$b(obj, key, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key] = value;
var __publicField$b = (obj, key, value) => {
  __defNormalProp$b(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class ComponentBuilder {
  constructor(spec) {
    __publicField$b(this, "spec");
    this.spec = {
      options: {},
      ...(spec ? spec : {})
    };
  }
  id(id) {
    return this.clone({
      id
    });
  }
  getId() {
    return this.spec.id;
  }
  title(title) {
    return this.clone({
      title,
      id: getStructureNodeId(title, this.spec.id)
    });
  }
  getTitle() {
    return this.spec.title;
  }
  child(child) {
    return this.clone({
      child
    });
  }
  getChild() {
    return this.spec.child;
  }
  component(component) {
    return this.clone({
      component
    });
  }
  getComponent() {
    return this.spec.component;
  }
  options(options) {
    return this.clone({
      options
    });
  }
  getOptions() {
    return this.spec.options || {};
  }
  menuItems(menuItems) {
    return this.clone({
      menuItems
    });
  }
  getMenuItems() {
    return this.spec.menuItems;
  }
  menuItemGroups(menuItemGroups) {
    return this.clone({
      menuItemGroups
    });
  }
  getMenuItemGroups() {
    return this.spec.menuItemGroups;
  }
  serialize() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      path: []
    };
    const {
      id,
      title,
      child,
      options: componentOptions,
      component
    } = this.spec;
    if (!id) {
      throw new SerializeError("`id` is required for `component` structure item", options.path, options.index).withHelpUrl(HELP_URL.ID_REQUIRED);
    }
    if (!component) {
      throw new SerializeError("`component` is required for `component` structure item", options.path, options.index).withHelpUrl(HELP_URL.ID_REQUIRED);
    }
    return {
      id: validateId(id, options.path, options.index),
      title,
      type: "component",
      child,
      component,
      options: componentOptions || {},
      menuItems: (this.spec.menuItems || []).map((item, i) => maybeSerializeMenuItem(item, i, options.path)),
      menuItemGroups: (this.spec.menuItemGroups || []).map((item, i) => maybeSerializeMenuItemGroup(item, i, options.path))
    };
  }
  clone(withSpec) {
    const builder = new ComponentBuilder();
    builder.spec = {
      ...this.spec,
      ...(withSpec || {})
    };
    return builder;
  }
}
async function resolveTypeForDocument(getClient, id) {
  const query = "*[_id in [$documentId, $draftId]]._type";
  const documentId = getPublishedId(id);
  const draftId = getDraftId(id);
  const types = await getClient(DEFAULT_STUDIO_CLIENT_OPTIONS).fetch(query, {
    documentId,
    draftId
  }, {
    tag: "structure.resolve-type"
  });
  return types[0];
}
var __defProp$a = Object.defineProperty;
var __defNormalProp$a = (obj, key, value) => key in obj ? __defProp$a(obj, key, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key] = value;
var __publicField$a = (obj, key, value) => {
  __defNormalProp$a(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class GenericViewBuilder {
  constructor() {
    __publicField$a(this, "spec", {});
  }
  id(id) {
    return this.clone({
      id
    });
  }
  getId() {
    return this.spec.id;
  }
  title(title) {
    return this.clone({
      title,
      id: this.spec.id || kebabCase(title)
    });
  }
  getTitle() {
    return this.spec.title;
  }
  icon(icon) {
    return this.clone({
      icon
    });
  }
  getIcon() {
    return this.spec.icon;
  }
  serialize() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      path: []
    };
    const {
      id,
      title,
      icon
    } = this.spec;
    if (!id) {
      throw new SerializeError("`id` is required for view item", options.path, options.index).withHelpUrl(HELP_URL.ID_REQUIRED);
    }
    if (!title) {
      throw new SerializeError("`title` is required for view item", options.path, options.index).withHelpUrl(HELP_URL.TITLE_REQUIRED);
    }
    return {
      id: validateId(id, options.path, options.index),
      title,
      icon
    };
  }
}
function isSerializable(view) {
  return typeof view.serialize === "function";
}
function maybeSerializeView(item, index, path) {
  return isSerializable(item) ? item.serialize({
    path,
    index
  }) : item;
}
var __defProp$9 = Object.defineProperty;
var __defNormalProp$9 = (obj, key, value) => key in obj ? __defProp$9(obj, key, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key] = value;
var __publicField$9 = (obj, key, value) => {
  __defNormalProp$9(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
const isComponentSpec = spec => isRecord(spec) && spec.type === "component";
class ComponentViewBuilder extends GenericViewBuilder {
  constructor(componentOrSpec) {
    const spec = isComponentSpec(componentOrSpec) ? {
      ...componentOrSpec
    } : {
      options: {}
    };
    super();
    __publicField$9(this, "spec");
    this.spec = spec;
    const userComponent = typeof componentOrSpec === "function" ? componentOrSpec : this.spec.component;
    if (userComponent) {
      this.spec = this.component(userComponent).spec;
    }
  }
  component(component) {
    return this.clone({
      component
    });
  }
  getComponent() {
    return this.spec.component;
  }
  options(options) {
    return this.clone({
      options
    });
  }
  getOptions() {
    return this.spec.options || {};
  }
  serialize() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      path: []
    };
    const base = super.serialize(options);
    const component = this.spec.component;
    if (typeof component !== "function") {
      throw new SerializeError("`component` is required and must be a function for `component()` view item", options.path, options.index).withHelpUrl(HELP_URL.COMPONENT_REQUIRED);
    }
    return {
      ...base,
      component,
      options: this.spec.options || {},
      type: "component"
    };
  }
  clone(withSpec) {
    const builder = new ComponentViewBuilder();
    builder.spec = {
      ...this.spec,
      ...(withSpec || {})
    };
    return builder;
  }
}
var __defProp$8 = Object.defineProperty;
var __defNormalProp$8 = (obj, key, value) => key in obj ? __defProp$8(obj, key, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key] = value;
var __publicField$8 = (obj, key, value) => {
  __defNormalProp$8(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class FormViewBuilder extends GenericViewBuilder {
  constructor(spec) {
    super();
    __publicField$8(this, "spec");
    this.spec = {
      id: "editor",
      title: "Editor",
      ...(spec ? spec : {})
    };
  }
  serialize() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      path: []
    };
    return {
      ...super.serialize(options),
      type: "form"
    };
  }
  clone(withSpec) {
    const builder = new FormViewBuilder();
    builder.spec = {
      ...this.spec,
      ...(withSpec || {})
    };
    return builder;
  }
}
const form = spec => new FormViewBuilder(spec);
const component = componentOrSpec => new ComponentViewBuilder(componentOrSpec);
var views = /*#__PURE__*/Object.freeze({
  __proto__: null,
  ComponentViewBuilder: ComponentViewBuilder,
  FormViewBuilder: FormViewBuilder,
  GenericViewBuilder: GenericViewBuilder,
  component: component,
  form: form,
  maybeSerializeView: maybeSerializeView
});
var __defProp$7 = Object.defineProperty;
var __defNormalProp$7 = (obj, key, value) => key in obj ? __defProp$7(obj, key, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key] = value;
var __publicField$7 = (obj, key, value) => {
  __defNormalProp$7(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
const createDocumentChildResolver = _ref44 => {
  let {
    resolveDocumentNode,
    getClient
  } = _ref44;
  return async (itemId, _ref45) => {
    let {
      params,
      path
    } = _ref45;
    let type = params.type;
    const parentPath = path.slice(0, path.length - 1);
    const currentSegment = path[path.length - 1];
    if (!type) {
      type = await resolveTypeForDocument(getClient, itemId);
    }
    if (!type) {
      throw new SerializeError("Failed to resolve document, and no type provided in parameters.", parentPath, currentSegment);
    }
    return resolveDocumentNode({
      documentId: itemId,
      schemaType: type
    });
  };
};
class DocumentBuilder {
  constructor(_context, spec) {
    this._context = _context;
    __publicField$7(this, "spec");
    this.spec = spec ? spec : {};
  }
  id(id) {
    return this.clone({
      id
    });
  }
  getId() {
    return this.spec.id;
  }
  title(title) {
    return this.clone({
      title,
      id: getStructureNodeId(title, this.spec.id)
    });
  }
  getTitle() {
    return this.spec.title;
  }
  child(child) {
    return this.clone({
      child
    });
  }
  getChild() {
    return this.spec.child;
  }
  documentId(documentId) {
    const paneId = this.spec.id || documentId;
    return this.clone({
      id: paneId,
      options: {
        ...(this.spec.options || {}),
        id: documentId
      }
    });
  }
  getDocumentId() {
    var _a;
    return (_a = this.spec.options) == null ? void 0 : _a.id;
  }
  schemaType(documentType) {
    return this.clone({
      options: {
        ...(this.spec.options || {}),
        type: typeof documentType === "string" ? documentType : documentType.name
      }
    });
  }
  getSchemaType() {
    var _a;
    return (_a = this.spec.options) == null ? void 0 : _a.type;
  }
  initialValueTemplate(templateId, parameters) {
    return this.clone({
      options: {
        ...(this.spec.options || {}),
        template: templateId,
        templateParameters: parameters
      }
    });
  }
  getInitialValueTemplate() {
    var _a;
    return (_a = this.spec.options) == null ? void 0 : _a.template;
  }
  getInitialValueTemplateParameters() {
    var _a;
    return (_a = this.spec.options) == null ? void 0 : _a.templateParameters;
  }
  views(views) {
    return this.clone({
      views
    });
  }
  getViews() {
    return this.spec.views || [];
  }
  serialize() {
    let {
      path = [],
      index,
      hint
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      path: []
    };
    const urlId = path[index || path.length - 1];
    const id = this.spec.id || urlId && "".concat(urlId) || "";
    const options = {
      id,
      type: void 0,
      template: void 0,
      templateParameters: void 0,
      ...this.spec.options
    };
    if (typeof id !== "string" || !id) {
      throw new SerializeError("`id` is required for document nodes", path, index, hint).withHelpUrl(HELP_URL.ID_REQUIRED);
    }
    if (!options || !options.id) {
      throw new SerializeError("document id (`id`) is required for document nodes", path, id, hint).withHelpUrl(HELP_URL.DOCUMENT_ID_REQUIRED);
    }
    if (!options || !options.type) {
      throw new SerializeError("document type (`schemaType`) is required for document nodes", path, id, hint);
    }
    const views = (this.spec.views && this.spec.views.length > 0 ? this.spec.views : [form()]).map((item, i) => maybeSerializeView(item, i, path));
    const viewIds = views.map(view => view.id);
    const dupes = uniq(viewIds.filter((viewId, i) => viewIds.includes(viewId, i + 1)));
    if (dupes.length > 0) {
      throw new SerializeError("document node has views with duplicate IDs: ".concat(dupes.join(",  ")), path, id, hint);
    }
    return {
      ...this.spec,
      child: this.spec.child || createDocumentChildResolver(this._context),
      id: validateId(id, path, index),
      type: "document",
      options: getDocumentOptions(options),
      views
    };
  }
  clone() {
    let withSpec = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const builder = new DocumentBuilder(this._context);
    const options = {
      ...(this.spec.options || {}),
      ...(withSpec.options || {})
    };
    builder.spec = {
      ...this.spec,
      ...withSpec,
      options
    };
    return builder;
  }
}
function getDocumentOptions(spec) {
  const opts = {
    id: spec.id || "",
    type: spec.type || "*"
  };
  if (spec.template) {
    opts.template = spec.template;
  }
  if (spec.templateParameters) {
    opts.templateParameters = spec.templateParameters;
  }
  return opts;
}
function documentFromEditor(context, spec) {
  let doc = (spec == null ? void 0 : spec.type) ?
  // Use user-defined document fragment as base if possible
  context.resolveDocumentNode({
    schemaType: spec.type
  }) :
  // Fall back to plain old document builder
  new DocumentBuilder(context);
  if (!spec) return doc;
  const {
    id,
    type,
    template,
    templateParameters
  } = spec.options;
  doc = doc.id(spec.id).documentId(id);
  if (type) {
    doc = doc.schemaType(type);
  }
  if (template) {
    doc = doc.initialValueTemplate(template, templateParameters);
  }
  if (spec.child) {
    doc = doc.child(spec.child);
  }
  return doc;
}
function documentFromEditorWithInitialValue(_ref46, templateId, parameters) {
  let {
    resolveDocumentNode,
    templates
  } = _ref46;
  const template = templates.find(t => t.id === templateId);
  if (!template) {
    throw new Error("Template with ID \"".concat(templateId, "\" not defined"));
  }
  return resolveDocumentNode({
    schemaType: template.schemaType
  }).initialValueTemplate(templateId, parameters);
}
const layoutOptions = ["default", "card", "media", "detail", "block"];
const DEFAULT_INTENT_HANDLER = Symbol("Document type list canHandleIntent");
const defaultIntentChecker = (intentName, params, _ref47) => {
  let {
    pane
  } = _ref47;
  var _a, _b;
  const isEdit = intentName === "edit";
  const isCreate = intentName === "create";
  const typedSpec = pane;
  const paneFilter = ((_a = typedSpec.options) == null ? void 0 : _a.filter) || "";
  const paneParams = ((_b = typedSpec.options) == null ? void 0 : _b.params) || {};
  const typeNames = typedSpec.schemaTypeName ? [typedSpec.schemaTypeName] : getTypeNamesFromFilter(paneFilter, paneParams);
  const initialValueTemplates = typedSpec.initialValueTemplates || [];
  if (isCreate && params.template) {
    return initialValueTemplates.some(tpl => tpl.templateId === params.template);
  }
  return isEdit && params.id && typeNames.includes(params.type) || isCreate && typeNames.includes(params.type);
};
defaultIntentChecker.identity = DEFAULT_INTENT_HANDLER;
var __defProp$6 = Object.defineProperty;
var __defNormalProp$6 = (obj, key, value) => key in obj ? __defProp$6(obj, key, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key] = value;
var __publicField$6 = (obj, key, value) => {
  __defNormalProp$6(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class InitialValueTemplateItemBuilder {
  constructor(_context, spec) {
    this._context = _context;
    __publicField$6(this, "spec");
    this.spec = spec ? spec : {};
  }
  id(id) {
    return this.clone({
      id
    });
  }
  getId() {
    return this.spec.id;
  }
  title(title) {
    return this.clone({
      title
    });
  }
  getTitle() {
    return this.spec.title;
  }
  description(description) {
    return this.clone({
      description
    });
  }
  getDescription() {
    return this.spec.description;
  }
  templateId(templateId) {
    const paneId = this.spec.id || templateId;
    return this.clone({
      id: paneId,
      templateId
    });
  }
  getTemplateId() {
    return this.spec.templateId;
  }
  parameters(parameters) {
    return this.clone({
      parameters
    });
  }
  getParameters() {
    return this.spec.parameters;
  }
  serialize() {
    let {
      path = [],
      index,
      hint
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      path: []
    };
    const {
      spec,
      _context
    } = this;
    const {
      templates
    } = _context;
    if (typeof spec.id !== "string" || !spec.id) {
      throw new SerializeError("`id` is required for initial value template item nodes", path, index, hint).withHelpUrl(HELP_URL.ID_REQUIRED);
    }
    if (!spec.templateId) {
      throw new SerializeError("template id (`templateId`) is required for initial value template item nodes", path, spec.id, hint).withHelpUrl(HELP_URL.ID_REQUIRED);
    }
    const template = templates.find(t => t.id === spec.templateId);
    if (!template) {
      throw new SerializeError("template id (`templateId`) is required for initial value template item nodes", path, spec.id, hint).withHelpUrl(HELP_URL.ID_REQUIRED);
    }
    return {
      id: spec.id,
      templateId: spec.id,
      schemaType: template.schemaType,
      type: "initialValueTemplateItem",
      description: spec.description || template.description,
      title: spec.title || template.title,
      subtitle: spec.subtitle,
      icon: spec.icon || template.icon,
      initialDocumentId: spec.initialDocumentId,
      parameters: spec.parameters
    };
  }
  clone() {
    let withSpec = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const builder = new InitialValueTemplateItemBuilder(this._context);
    builder.spec = {
      ...this.spec,
      ...withSpec
    };
    return builder;
  }
}
function defaultInitialValueTemplateItems(context) {
  const {
    schema,
    getStructureBuilder,
    templates
  } = context;
  const typeNames = schema.getTypeNames();
  const ordered = templates.filter(tpl => {
    var _a;
    return !((_a = tpl.parameters) == null ? void 0 : _a.length);
  }).sort((a, b) => typeNames.indexOf(a.schemaType) - typeNames.indexOf(b.schemaType));
  return ordered.map(tpl => getStructureBuilder().initialValueTemplateItem(tpl.id));
}
function maybeSerializeInitialValueTemplateItem(item, index, path) {
  return item instanceof InitialValueTemplateItemBuilder ? item.serialize({
    path,
    index
  }) : item;
}
function menuItemsFromInitialValueTemplateItems(context, templateItems) {
  const {
    schema,
    templates
  } = context;
  return templateItems.map(item => {
    const template = templates.find(t => t.id === item.templateId);
    const title = item.title || (template == null ? void 0 : template.title) || "Create new";
    const params = pickBy({
      type: template && template.schemaType,
      template: item.templateId
    }, Boolean);
    const intentParams = item.parameters ? [params, item.parameters] : params;
    const schemaType = template && schema.get(template.schemaType);
    return new MenuItemBuilder(context).title(title).icon(template && template.icon || (schemaType == null ? void 0 : schemaType.icon) || ComposeIcon).intent({
      type: "create",
      params: intentParams
    }).serialize();
  });
}
var __defProp$5 = Object.defineProperty;
var __defNormalProp$5 = (obj, key, value) => key in obj ? __defProp$5(obj, key, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key] = value;
var __publicField$5 = (obj, key, value) => {
  __defNormalProp$5(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
function noChildResolver() {
  return void 0;
}
const shallowIntentChecker = (intentName, params, _ref48) => {
  let {
    pane,
    index
  } = _ref48;
  return index <= 1 && defaultIntentChecker(intentName, params, {
    pane,
    index
  });
};
class GenericListBuilder {
  constructor() {
    __publicField$5(this, "initialValueTemplatesSpecified", false);
    __publicField$5(this, "spec", {});
  }
  id(id) {
    return this.clone({
      id
    });
  }
  getId() {
    return this.spec.id;
  }
  title(title) {
    return this.clone({
      title,
      id: getStructureNodeId(title, this.spec.id)
    });
  }
  getTitle() {
    return this.spec.title;
  }
  defaultLayout(defaultLayout) {
    return this.clone({
      defaultLayout
    });
  }
  getDefaultLayout() {
    return this.spec.defaultLayout;
  }
  menuItems(menuItems) {
    return this.clone({
      menuItems
    });
  }
  getMenuItems() {
    return this.spec.menuItems;
  }
  menuItemGroups(menuItemGroups) {
    return this.clone({
      menuItemGroups
    });
  }
  getMenuItemGroups() {
    return this.spec.menuItemGroups;
  }
  child(child) {
    return this.clone({
      child
    });
  }
  getChild() {
    return this.spec.child;
  }
  canHandleIntent(canHandleIntent) {
    return this.clone({
      canHandleIntent
    });
  }
  getCanHandleIntent() {
    return this.spec.canHandleIntent;
  }
  showIcons() {
    let enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
    return this.clone({
      displayOptions: {
        ...(this.spec.displayOptions || {}),
        showIcons: enabled
      }
    });
  }
  getShowIcons() {
    return this.spec.displayOptions ? this.spec.displayOptions.showIcons : void 0;
  }
  initialValueTemplates(templates) {
    this.initialValueTemplatesSpecified = true;
    return this.clone({
      initialValueTemplates: Array.isArray(templates) ? templates : [templates]
    });
  }
  getInitialValueTemplates() {
    return this.spec.initialValueTemplates;
  }
  serialize() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      path: []
    };
    const id = this.spec.id || "";
    const path = options.path;
    const defaultLayout = this.spec.defaultLayout;
    if (defaultLayout && !layoutOptions.includes(defaultLayout)) {
      throw new SerializeError("`layout` must be one of ".concat(layoutOptions.map(item => "\"".concat(item, "\"")).join(", ")), path, id || options.index, this.spec.title);
    }
    const initialValueTemplates = (this.spec.initialValueTemplates || []).map((item, i) => maybeSerializeInitialValueTemplateItem(item, i, path));
    return {
      id: validateId(id, options.path, id || options.index),
      title: this.spec.title,
      type: "genericList",
      defaultLayout,
      child: this.spec.child || noChildResolver,
      canHandleIntent: this.spec.canHandleIntent || shallowIntentChecker,
      displayOptions: this.spec.displayOptions,
      initialValueTemplates,
      menuItems: (this.spec.menuItems || []).map((item, i) => maybeSerializeMenuItem(item, i, path)),
      menuItemGroups: (this.spec.menuItemGroups || []).map((item, i) => maybeSerializeMenuItemGroup(item, i, path))
    };
  }
}
var __defProp$4 = Object.defineProperty;
var __defNormalProp$4 = (obj, key, value) => key in obj ? __defProp$4(obj, key, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key] = value;
var __publicField$4 = (obj, key, value) => {
  __defNormalProp$4(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
const validateFilter = (spec, options) => {
  var _a;
  const filter = ((_a = spec.options) == null ? void 0 : _a.filter.trim()) || "";
  if (["*", "{"].includes(filter[0])) {
    throw new SerializeError("`filter` cannot start with `".concat(filter[0], "` - looks like you are providing a query, not a filter"), options.path, spec.id, spec.title).withHelpUrl(HELP_URL.QUERY_PROVIDED_FOR_FILTER);
  }
  return filter;
};
const createDocumentChildResolverForItem = context => (itemId, options) => {
  var _a;
  const parentItem = options.parent;
  const template = ((_a = options.params) == null ? void 0 : _a.template) ? context.templates.find(tpl => tpl.id === options.params.template) : void 0;
  const type = template ? template.schemaType : parentItem.schemaTypeName || resolveTypeForDocument(context.getClient, itemId);
  return Promise.resolve(type).then(schemaType => schemaType ? context.resolveDocumentNode({
    schemaType,
    documentId: itemId
  }) : new DocumentBuilder(context).id("editor").documentId(itemId).schemaType(""));
};
class DocumentListBuilder extends GenericListBuilder {
  constructor(_context, spec) {
    super();
    this._context = _context;
    __publicField$4(this, "spec");
    this.spec = spec || {};
    this.initialValueTemplatesSpecified = Boolean(spec == null ? void 0 : spec.initialValueTemplates);
  }
  apiVersion(apiVersion) {
    return this.clone({
      options: {
        ...(this.spec.options || {
          filter: ""
        }),
        apiVersion
      }
    });
  }
  getApiVersion() {
    var _a;
    return (_a = this.spec.options) == null ? void 0 : _a.apiVersion;
  }
  filter(filter) {
    return this.clone({
      options: {
        ...(this.spec.options || {}),
        filter
      }
    });
  }
  getFilter() {
    var _a;
    return (_a = this.spec.options) == null ? void 0 : _a.filter;
  }
  schemaType(type) {
    const schemaTypeName = typeof type === "string" ? type : type.name;
    return this.clone({
      schemaTypeName
    });
  }
  getSchemaType() {
    return this.spec.schemaTypeName;
  }
  params(params) {
    return this.clone({
      options: {
        ...(this.spec.options || {
          filter: ""
        }),
        params
      }
    });
  }
  getParams() {
    var _a;
    return (_a = this.spec.options) == null ? void 0 : _a.params;
  }
  defaultOrdering(ordering) {
    if (!Array.isArray(ordering)) {
      throw new Error("`defaultOrdering` must be an array of order clauses");
    }
    return this.clone({
      options: {
        ...(this.spec.options || {
          filter: ""
        }),
        defaultOrdering: ordering
      }
    });
  }
  getDefaultOrdering() {
    var _a;
    return (_a = this.spec.options) == null ? void 0 : _a.defaultOrdering;
  }
  serialize() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      path: []
    };
    var _a;
    if (typeof this.spec.id !== "string" || !this.spec.id) {
      throw new SerializeError("`id` is required for document lists", options.path, options.index, this.spec.title).withHelpUrl(HELP_URL.ID_REQUIRED);
    }
    if (!this.spec.options || !this.spec.options.filter) {
      throw new SerializeError("`filter` is required for document lists", options.path, this.spec.id, this.spec.title).withHelpUrl(HELP_URL.FILTER_REQUIRED);
    }
    return {
      ...super.serialize(options),
      type: "documentList",
      schemaTypeName: this.spec.schemaTypeName,
      child: this.spec.child || createDocumentChildResolverForItem(this._context),
      options: {
        ...this.spec.options,
        apiVersion: this.spec.options.apiVersion || (
        // If this is a simple type filter, use modern API version - otherwise default to v1
        ((_a = this.spec.options) == null ? void 0 : _a.filter) === "_type == $type" ? "2021-06-07" : "1"),
        filter: validateFilter(this.spec, options)
      }
    };
  }
  clone(withSpec) {
    const builder = new DocumentListBuilder(this._context);
    builder.spec = {
      ...this.spec,
      ...(withSpec || {})
    };
    if (!this.initialValueTemplatesSpecified) {
      builder.spec.initialValueTemplates = inferInitialValueTemplates(this._context, builder.spec);
    }
    if (!builder.spec.schemaTypeName) {
      builder.spec.schemaTypeName = inferTypeName(builder.spec);
    }
    return builder;
  }
  getSpec() {
    return this.spec;
  }
}
function inferInitialValueTemplates(context, spec) {
  const {
    document
  } = context;
  const {
    schemaTypeName,
    options
  } = spec;
  const {
    filter,
    params
  } = options || {
    filter: "",
    params: {}
  };
  const typeNames = schemaTypeName ? [schemaTypeName] : Array.from(new Set(getTypeNamesFromFilter(filter, params)));
  if (typeNames.length === 0) {
    return void 0;
  }
  return typeNames.flatMap(schemaType => document.resolveNewDocumentOptions({
    type: "structure",
    schemaType
  })).map(option => ({
    ...option,
    icon: ComposeIcon
  }));
}
function inferTypeName(spec) {
  const {
    options
  } = spec;
  const {
    filter,
    params
  } = options || {
    filter: "",
    params: {}
  };
  const typeNames = getTypeNamesFromFilter(filter, params);
  return typeNames.length === 1 ? typeNames[0] : void 0;
}
function getTypeNamesFromFilter(filter) {
  let params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  let typeNames = getTypeNamesFromEqualityFilter(filter, params);
  if (typeNames.length === 0) {
    typeNames = getTypeNamesFromInTypesFilter(filter, params);
  }
  return typeNames;
}
function getTypeNamesFromEqualityFilter(filter) {
  let params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const pattern = /\b_type\s*==\s*(['"].*?['"]|\$.*?(?:\s|$))|\B(['"].*?['"]|\$.*?(?:\s|$))\s*==\s*_type/g;
  const matches = [];
  let match;
  while ((match = pattern.exec(filter)) !== null) {
    matches.push(match[1] || match[2]);
  }
  return matches.map(candidate => {
    const typeName = candidate[0] === "$" ? params[candidate.slice(1)] : candidate;
    const normalized = (typeName || "").trim().replace(/^["']|["']$/g, "");
    return normalized;
  }).filter(Boolean);
}
function getTypeNamesFromInTypesFilter(filter) {
  let params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const pattern = /\b_type\s+in\s+\[(.*?)\]/;
  const matches = filter.match(pattern);
  if (!matches) {
    return [];
  }
  return matches[1].split(/,\s*/).map(match => match.trim().replace(/^["']+|["']+$/g, "")).map(item => item[0] === "$" ? params[item.slice(1)] : item).filter(Boolean);
}
var __defProp$3 = Object.defineProperty;
var __defNormalProp$3 = (obj, key, value) => key in obj ? __defProp$3(obj, key, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key] = value;
var __publicField$3 = (obj, key, value) => {
  __defNormalProp$3(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
const getArgType = thing => {
  if (thing instanceof ListBuilder) {
    return "ListBuilder";
  }
  if (isPromise(thing)) {
    return "Promise";
  }
  return Array.isArray(thing) ? "array" : typeof thing;
};
const isListItem = item => {
  return item.type === "listItem";
};
const defaultCanHandleIntent = (intentName, params, context) => {
  const pane = context.pane;
  const items = pane.items || [];
  return items.filter(isDocumentListItem).some(item => item.schemaType.name === params.type && item._id === params.id) || shallowIntentChecker(intentName, params, context);
};
const resolveChildForItem = (itemId, options) => {
  const parentItem = options.parent;
  const items = parentItem.items.filter(isListItem);
  const target = (items.find(item => item.id === itemId) || {
    child: void 0
  }).child;
  if (!target || typeof target !== "function") {
    return target;
  }
  return typeof target === "function" ? target(itemId, options) : target;
};
function maybeSerializeListItem(item, index, path) {
  if (item instanceof ListItemBuilder) {
    return item.serialize({
      path,
      index
    });
  }
  const listItem = item;
  if (listItem && listItem.type === "divider") {
    return item;
  }
  if (!listItem || listItem.type !== "listItem") {
    const gotWhat = listItem && listItem.type || getArgType(listItem);
    const helpText = gotWhat === "array" ? " - did you forget to spread (...moreItems)?" : "";
    throw new SerializeError("List items must be of type \"listItem\", got \"".concat(gotWhat, "\"").concat(helpText), path, index).withHelpUrl(HELP_URL.INVALID_LIST_ITEM);
  }
  return item;
}
function isPromise(thing) {
  return isRecord(thing) && typeof thing.then === "function";
}
class ListBuilder extends GenericListBuilder {
  constructor(_context, spec) {
    super();
    this._context = _context;
    __publicField$3(this, "spec");
    this.spec = spec ? spec : {};
    this.initialValueTemplatesSpecified = Boolean(spec && spec.initialValueTemplates);
  }
  items(items) {
    return this.clone({
      items
    });
  }
  getItems() {
    return this.spec.items;
  }
  serialize() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      path: []
    };
    const id = this.spec.id;
    if (typeof id !== "string" || !id) {
      throw new SerializeError("`id` is required for lists", options.path, options.index).withHelpUrl(HELP_URL.ID_REQUIRED);
    }
    const items = typeof this.spec.items === "undefined" ? [] : this.spec.items;
    if (!Array.isArray(items)) {
      throw new SerializeError("`items` must be an array of items", options.path, options.index).withHelpUrl(HELP_URL.LIST_ITEMS_MUST_BE_ARRAY);
    }
    const path = (options.path || []).concat(id);
    const serializedItems = items.map((item, index) => maybeSerializeListItem(item, index, path));
    const dupes = serializedItems.filter((val, i) => find(serializedItems, {
      id: val.id
    }, i + 1));
    if (dupes.length > 0) {
      const dupeIds = dupes.map(item => item.id).slice(0, 5);
      const dupeDesc = dupes.length > 5 ? "".concat(dupeIds.join(", "), "...") : dupeIds.join(", ");
      throw new SerializeError("List items with same ID found (".concat(dupeDesc, ")"), options.path, options.index).withHelpUrl(HELP_URL.LIST_ITEM_IDS_MUST_BE_UNIQUE);
    }
    return {
      ...super.serialize(options),
      type: "list",
      canHandleIntent: this.spec.canHandleIntent || defaultCanHandleIntent,
      child: this.spec.child || resolveChildForItem,
      items: serializedItems
    };
  }
  clone(withSpec) {
    const builder = new ListBuilder(this._context);
    builder.spec = {
      ...this.spec,
      ...(withSpec || {})
    };
    return builder;
  }
}
var __defProp$2 = Object.defineProperty;
var __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key] = value;
var __publicField$2 = (obj, key, value) => {
  __defNormalProp$2(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class ListItemBuilder {
  constructor(_context, spec) {
    this._context = _context;
    __publicField$2(this, "spec");
    this.spec = spec ? spec : {};
  }
  id(id) {
    return this.clone({
      id
    });
  }
  getId() {
    return this.spec.id;
  }
  title(title) {
    return this.clone({
      title,
      id: getStructureNodeId(title, this.spec.id)
    });
  }
  getTitle() {
    return this.spec.title;
  }
  icon(icon) {
    return this.clone({
      icon
    });
  }
  showIcon() {
    let enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
    return this.clone({
      displayOptions: {
        ...(this.spec.displayOptions || {}),
        showIcon: enabled
      }
    });
  }
  getShowIcon() {
    return this.spec.displayOptions ? this.spec.displayOptions.showIcon : void 0;
  }
  getIcon() {
    return this.spec.icon;
  }
  child(child) {
    return this.clone({
      child
    });
  }
  getChild() {
    return this.spec.child;
  }
  schemaType(schemaType) {
    return this.clone({
      schemaType
    });
  }
  getSchemaType() {
    const schemaType = this.spec.schemaType;
    if (typeof schemaType === "string") {
      return this._context.schema.get(schemaType);
    }
    return this.spec.schemaType;
  }
  serialize() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      path: []
    };
    const {
      id,
      title,
      child
    } = this.spec;
    if (typeof id !== "string" || !id) {
      throw new SerializeError("`id` is required for list items", options.path, options.index).withHelpUrl(HELP_URL.ID_REQUIRED);
    }
    if (!options.titleIsOptional && (typeof title !== "string" || !title)) {
      throw new SerializeError("`title` is required for list items", options.path, id).withHelpUrl(HELP_URL.TITLE_REQUIRED);
    }
    let schemaType = this.spec.schemaType;
    if (typeof schemaType === "string") {
      const type = this._context.schema.get(schemaType);
      if (!type) {
        throw new SerializeError("Could not find type \"".concat(schemaType, "\" in schema"), options.path, id).withHelpUrl(HELP_URL.SCHEMA_TYPE_NOT_FOUND);
      }
      schemaType = type;
    }
    const serializeOptions = {
      path: options.path.concat(id),
      hint: "child"
    };
    let listChild = child instanceof ComponentBuilder || child instanceof DocumentListBuilder || child instanceof DocumentBuilder || child instanceof ListBuilder ? child.serialize(serializeOptions) : child;
    if (typeof listChild === "function") {
      const originalChild = listChild;
      listChild = (itemId, childOptions) => {
        return originalChild(itemId, {
          ...childOptions,
          serializeOptions
        });
      };
    }
    return {
      ...this.spec,
      id: validateId(id, options.path, options.index),
      schemaType,
      child: listChild,
      title,
      type: "listItem"
    };
  }
  clone(withSpec) {
    const builder = new ListItemBuilder(this._context);
    builder.spec = {
      ...this.spec,
      ...(withSpec || {})
    };
    return builder;
  }
}
var __defProp$1 = Object.defineProperty;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key] = value;
var __publicField$1 = (obj, key, value) => {
  __defNormalProp$1(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
const createDefaultChildResolver = (context, spec) => documentId => {
  const schemaType = spec.schemaType && (typeof spec.schemaType === "string" ? spec.schemaType : spec.schemaType.name);
  return schemaType ? context.resolveDocumentNode({
    schemaType,
    documentId
  }) : new DocumentBuilder(context).id("documentEditor").documentId(documentId);
};
class DocumentListItemBuilder extends ListItemBuilder {
  constructor(_context, spec) {
    super(_context, spec);
    this._context = _context;
    __publicField$1(this, "spec");
    this.spec = spec ? spec : {};
  }
  serialize() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      path: []
    };
    const spec = super.serialize({
      ...options,
      titleIsOptional: true
    });
    if (!spec.schemaType) {
      throw new SerializeError("`schemaType` is required for document list items", options.path, options.index).withHelpUrl(HELP_URL.SCHEMA_TYPE_REQUIRED);
    }
    const child = spec.child || createDefaultChildResolver(this._context, spec);
    return {
      ...spec,
      child,
      schemaType: spec.schemaType,
      _id: spec.id
    };
  }
  clone(withSpec) {
    const builder = new DocumentListItemBuilder(this._context);
    builder.spec = {
      ...this.spec,
      ...(withSpec || {})
    };
    return builder;
  }
}
function isDocumentListItem(item) {
  return isRecord(item) && typeof item.schemaType !== "undefined" && typeof item._id === "string";
}
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class DocumentTypeListBuilder extends DocumentListBuilder {
  constructor(_context, spec) {
    super(_context);
    this._context = _context;
    __publicField(this, "spec");
    this.spec = spec ? spec : {};
  }
  child(child) {
    return this.cloneWithoutDefaultIntentHandler({
      child
    });
  }
  clone(withSpec) {
    const parent = super.clone(withSpec);
    const builder = new DocumentTypeListBuilder(this._context);
    builder.spec = {
      ...this.spec,
      ...parent.getSpec(),
      ...(withSpec || {})
    };
    return builder;
  }
  cloneWithoutDefaultIntentHandler(withSpec) {
    const parent = super.clone(withSpec);
    const builder = new DocumentTypeListBuilder(this._context);
    const canHandleIntent = this.spec.canHandleIntent;
    const shouldOverride = canHandleIntent && canHandleIntent.identity === DEFAULT_INTENT_HANDLER;
    const override = shouldOverride ? {
      canHandleIntent: void 0
    } : {};
    builder.spec = {
      ...parent.getSpec(),
      ...this.spec,
      ...(withSpec || {}),
      ...override
    };
    return builder;
  }
}
function shouldShowIcon(schemaType) {
  const preview = schemaType.preview;
  return Boolean(preview && (preview.prepare || preview.select && preview.select.media));
}
const BUNDLED_DOC_TYPES = ["sanity.imageAsset", "sanity.fileAsset"];
function isBundledDocType(typeName) {
  return BUNDLED_DOC_TYPES.includes(typeName);
}
function isDocumentType(schemaType) {
  var _a;
  return ((_a = schemaType.type) == null ? void 0 : _a.name) === "document";
}
function isList(collection) {
  return collection.type === "list";
}
function getDocumentTypes(_ref49) {
  let {
    schema
  } = _ref49;
  return schema.getTypeNames().filter(n => {
    const schemaType = schema.get(n);
    return schemaType && isDocumentType(schemaType);
  }).filter(n => !isBundledDocType(n));
}
function getDocumentTypeListItems(context) {
  const types = getDocumentTypes(context);
  return types.map(typeName => getDocumentTypeListItem(context, typeName));
}
function getDocumentTypeListItem(context, typeName) {
  const {
    schema
  } = context;
  const type = schema.get(typeName);
  if (!type) {
    throw new Error("Schema type with name \"".concat(typeName, "\" not found"));
  }
  const title = type.title || startCase(typeName);
  return new ListItemBuilder(context).id(typeName).title(title).schemaType(type).child((id, childContext) => {
    const parent = childContext.parent;
    const parentItem = isList(parent) ? parent.items.find(item => item.id === id) : null;
    let list = getDocumentTypeList(context, typeName);
    if (parentItem && parentItem.title) {
      list = list.title(parentItem.title);
    }
    return list;
  });
}
function getDocumentTypeList(context, typeNameOrSpec) {
  const {
    schema,
    resolveDocumentNode
  } = context;
  const schemaType = typeof typeNameOrSpec === "string" ? typeNameOrSpec : typeNameOrSpec.schemaType;
  const typeName = typeof schemaType === "string" ? schemaType : schemaType.name;
  const spec = typeof typeNameOrSpec === "string" ? {
    schemaType
  } : typeNameOrSpec;
  const type = schema.get(typeName);
  if (!type) {
    throw new Error("Schema type with name \"".concat(typeName, "\" not found"));
  }
  const title = type.title || startCase(typeName);
  const showIcons = shouldShowIcon(type);
  return new DocumentTypeListBuilder(context).id(spec.id || typeName).title(spec.title || title).filter("_type == $type").params({
    type: typeName
  }).schemaType(type).showIcons(showIcons).defaultOrdering(DEFAULT_SELECTED_ORDERING_OPTION.by).menuItemGroups(spec.menuItemGroups || [{
    id: "sorting",
    title: "Sort"
  }, {
    id: "layout",
    title: "Layout"
  }, {
    id: "actions",
    title: "Actions"
  }]).child(spec.child || (documentId => resolveDocumentNode({
    schemaType: typeName,
    documentId
  }))).canHandleIntent(spec.canHandleIntent || defaultIntentChecker).menuItems(spec.menuItems || [
  // Create new (from action button) will be added in serialization step of GenericList
  // Sort by <Y>
  ...getOrderingMenuItemsForSchemaType(context, type),
  // Display as <Z>
  new MenuItemBuilder(context).group("layout").title("Compact view").icon(StackCompactIcon).action("setLayout").params({
    layout: "default"
  }), new MenuItemBuilder(context).group("layout").title("Detailed view").icon(StackIcon).action("setLayout").params({
    layout: "detail"
  })
  // Create new (from menu) will be added in serialization step of GenericList
  ]);
}

function hasIcon(schemaType) {
  if (!schemaType || typeof schemaType === "string") {
    return false;
  }
  return Boolean(schemaType.icon);
}
function getDefaultStructure(context) {
  const items = getDocumentTypeListItems(context);
  return new ListBuilder(context).id("__root__").title("Content").items(items).showIcons(items.some(item => hasIcon(item.getSchemaType())));
}
function createStructureBuilder(_ref50) {
  let {
    defaultDocumentNode,
    source
  } = _ref50;
  const configContext = getConfigContextFromSource(source);
  const context = {
    ...source,
    getStructureBuilder: () => structureBuilder,
    resolveDocumentNode: options => {
      let builder = (defaultDocumentNode == null ? void 0 : defaultDocumentNode(structureBuilder, {
        ...options,
        ...configContext
      })) || new DocumentBuilder(context);
      if (!builder.getId()) {
        builder = builder.id("documentEditor");
      }
      if (options.documentId) {
        builder = builder.documentId(getPublishedId(options.documentId));
      }
      return builder.schemaType(options.schemaType);
    }
  };
  const structureBuilder = {
    defaults: () => getDefaultStructure(context),
    documentTypeList: function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return getDocumentTypeList(context, ...args);
    },
    documentTypeListItem: function () {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      return getDocumentTypeListItem(context, ...args);
    },
    documentTypeListItems: function () {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }
      return getDocumentTypeListItems(context, ...args);
    },
    document: function () {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }
      return new DocumentBuilder(context, ...args);
    },
    documentWithInitialValueTemplate: function () {
      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        args[_key5] = arguments[_key5];
      }
      return documentFromEditorWithInitialValue(context, ...args);
    },
    defaultDocument: context.resolveDocumentNode,
    list: function () {
      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
        args[_key6] = arguments[_key6];
      }
      return new ListBuilder(context, ...args);
    },
    listItem: function () {
      for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
        args[_key7] = arguments[_key7];
      }
      return new ListItemBuilder(context, ...args);
    },
    menuItem: function () {
      for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
        args[_key8] = arguments[_key8];
      }
      return new MenuItemBuilder(context, ...args);
    },
    menuItemGroup: function () {
      for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
        args[_key9] = arguments[_key9];
      }
      return new MenuItemGroupBuilder(context, ...args);
    },
    menuItemsFromInitialValueTemplateItems: function () {
      for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {
        args[_key10] = arguments[_key10];
      }
      return menuItemsFromInitialValueTemplateItems(context, ...args);
    },
    documentList: function () {
      for (var _len11 = arguments.length, args = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {
        args[_key11] = arguments[_key11];
      }
      return new DocumentListBuilder(context, ...args);
    },
    documentListItem: function () {
      for (var _len12 = arguments.length, args = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {
        args[_key12] = arguments[_key12];
      }
      return new DocumentListItemBuilder(context, ...args);
    },
    orderingMenuItem: function () {
      for (var _len13 = arguments.length, args = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {
        args[_key13] = arguments[_key13];
      }
      return getOrderingMenuItem(context, ...args);
    },
    orderingMenuItemsForType: function () {
      for (var _len14 = arguments.length, args = new Array(_len14), _key14 = 0; _key14 < _len14; _key14++) {
        args[_key14] = arguments[_key14];
      }
      return getOrderingMenuItemsForSchemaType(context, ...args);
    },
    editor: function () {
      for (var _len15 = arguments.length, args = new Array(_len15), _key15 = 0; _key15 < _len15; _key15++) {
        args[_key15] = arguments[_key15];
      }
      return documentFromEditor(context, ...args);
    },
    defaultInitialValueTemplateItems: function () {
      for (var _len16 = arguments.length, args = new Array(_len16), _key16 = 0; _key16 < _len16; _key16++) {
        args[_key16] = arguments[_key16];
      }
      return defaultInitialValueTemplateItems(context, ...args);
    },
    initialValueTemplateItem: (templateId, parameters) => new InitialValueTemplateItemBuilder(context, {
      id: templateId,
      parameters,
      templateId
    }),
    component: spec => {
      return isValidElementType(spec) ? new ComponentBuilder().component(spec) : new ComponentBuilder(spec);
    },
    divider: () => ({
      id: uniqueId("__divider__"),
      type: "divider"
    }),
    view: views,
    context
  };
  return structureBuilder;
}
function DeskToolProvider(_ref51) {
  let {
    defaultDocumentNode,
    structure: resolveStructure,
    children
  } = _ref51;
  const [layoutCollapsed, setLayoutCollapsed] = useState(false);
  const source = useSource();
  const configContext = useConfigContextFromSource(source);
  const documentStore = useDocumentStore();
  const S = useMemo(() => {
    return createStructureBuilder({
      defaultDocumentNode,
      source
    });
  }, [defaultDocumentNode, source]);
  const rootPaneNode = useMemo(() => {
    if (resolveStructure) return resolveStructure(S, {
      ...configContext,
      documentStore
    });
    return S.defaults();
  }, [S, resolveStructure, configContext, documentStore]);
  const features = useMemo(() => ({
    backButton: layoutCollapsed,
    resizablePanes: !layoutCollapsed,
    reviewChanges: !layoutCollapsed,
    splitPanes: !layoutCollapsed,
    splitViews: !layoutCollapsed
  }), [layoutCollapsed]);
  const deskTool = useMemo(() => {
    return {
      features,
      layoutCollapsed,
      setLayoutCollapsed,
      rootPaneNode,
      structureContext: S.context
    };
  }, [features, layoutCollapsed, rootPaneNode, S.context]);
  return /* @__PURE__ */jsx(DeskToolContext.Provider, {
    value: deskTool,
    children
  });
}
export { BackLink, ChildLink, ComponentBuilder, ComponentViewBuilder, ConfirmDeleteDialogContainer, DEFAULT_INTENT_HANDLER, DOCUMENT_INSPECTOR_MAX_WIDTH, DOCUMENT_INSPECTOR_MIN_WIDTH, DOCUMENT_PANEL_INITIAL_MIN_WIDTH, DOCUMENT_PANEL_MIN_WIDTH, DOCUMENT_PANEL_PORTAL_ELEMENT, Delay, DeskToolProvider, DocTitle, DocumentBuilder, DocumentInspectorHeader, DocumentListBuilder, DocumentListItemBuilder, DocumentPaneProvider, DocumentTypeListBuilder, FormViewBuilder, GenericListBuilder, GenericViewBuilder, HELP_URL, HistoryRestoreAction, InitialValueTemplateItemBuilder, LOADING_PANE, ListBuilder, ListItemBuilder, MenuItemBuilder, MenuItemGroupBuilder, PANE_COLLAPSED_WIDTH, PANE_DEFAULT_MIN_WIDTH, Pane, PaneContent, PaneContextMenuButton, PaneFooter, PaneHeader, PaneHeaderActionButton, PaneHeaderActions, PaneItemPreview, PaneLayoutContext, PaneRouterContext, ParameterizedLink, ReferenceChildLink, Resizable, Root$6 as Root, SerializeError, TimelineMenu, _DEBUG, component, createStructureBuilder, defaultInitialValueTemplateItems, defaultIntentChecker, deskTool, documentFromEditor, documentFromEditorWithInitialValue, form, getOrderingMenuItem, getOrderingMenuItemsForSchemaType, getTypeNamesFromFilter, isDocumentListItem, isMenuNodeButton, isNotMenuNodeButton, maybeSerializeInitialValueTemplateItem, maybeSerializeMenuItem, maybeSerializeMenuItemGroup, maybeSerializeView, menuItemsFromInitialValueTemplateItems, resolveMenuNodes, setActivePanes, shallowIntentChecker, useDeskTool, useDocumentPane, usePane, usePaneLayout, usePaneRouter };
//# sourceMappingURL=desk-5441fc6d.js.map
